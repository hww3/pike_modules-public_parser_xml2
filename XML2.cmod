/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: XML2.cmod,v 1.54 2005-04-25 19:06:37 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 *
 */

#include "xml2.h"

/*! @module Public
 */

/*! @module Parser
 */

/*! @module XML2
 */

/*
  
    start of Public.Parser.XML2 module functions

*/

CVAR PARSER_OBJECT_DATA * object_data;

/*! @decl array(Node) select_xpath_nodes(string xpath, object node)
 *!
 *! selects nodes based on an XPath query and returns the result.
 */
PIKEFUN array select_xpath_nodes(string xpath, object node)
{
  xmlXPathContextPtr xpathCtx;
  xmlXPathObjectPtr xpathObj;
  xmlNodeSetPtr set;
  xmlNodePtr xn;
  struct object * o;
  int num_nodes = 0;

  CHECK_NODE_PASSED(node);

//  check_node_created();
  if(OBJ2_NODE(node)->object_data->node == NULL)
  { 
    pop_n_elems(2);
    Pike_error("Node not initialized.\n");
  }

  xpathCtx = xmlXPathNewContext(OBJ2_NODE(node)->object_data->node->doc);
  if(xpathCtx == NULL)
  {
    pop_n_elems(2);
    Pike_error("Unable to create new XPath context.\n");
  }
  xpathObj = xmlXPathEvalExpression((xmlChar *)xpath->str, xpathCtx);
  if(xpathObj == NULL) {  
    pop_n_elems(2);
    xmlXPathFreeContext(xpathCtx);
    Pike_error("Unable to evaluate the XPath expression.\n");
  }

  /* now we should generate an array from the node set. */
  set = xpathObj->nodesetval;


  if(set == NULL)
  {
    pop_n_elems(2);
    push_int(0);
    xmlXPathFreeContext(xpathCtx);
    xmlXPathFreeObject(xpathObj);
    return;
  }  

  pop_n_elems(2);

  if(set->nodeNr > 0)
  {
  xn = set->nodeTab[0];
    if(xn != NULL && set->nodeNr > 0) do
    {
      struct Node_struct * ns;
      NODE_OBJECT_DATA * od;

      apply(Pike_fp->current_object, "Node", 0);
      ns = OBJ2_NODE((Pike_sp[0-1].u.object));
      od = (NODE_OBJECT_DATA *)(ns->object_data);

      od->node=xn;
      od->refs = OBJ2_NODE(node)->object_data->refs;
    
      (* od->refs)++;

      num_nodes++;
      xn = set->nodeTab[num_nodes];
    } 
    while (((num_nodes +1) <= set->nodeNr) && xn != NULL);


    if(num_nodes>0) {
      f_aggregate(num_nodes);
    }
  }
  else push_int(0);

  xmlXPathFreeContext(xpathCtx);
  xmlXPathFreeObject(xpathObj);

  return;
}

/*! @decl void set_parser_options(int options)
 *!
 *! sets parser options. 
 */
PIKEFUN void set_parser_options(int options)
{
  pop_stack();
}

/*! @decl int substituteEntitiesDefault(int def)
 */
PIKEFUN void substituteEntitiesDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  xmlSubstituteEntitiesDefault(def);

  push_int(def);
}

/* @decl int keepBlanksDefault(int def)
 */
PIKEFUN int keepBlanksDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  push_int(xmlKeepBlanksDefault(def));
}

/*!  @decl string utf8_to_html(string str)
 *!
 */
PIKEFUN string utf8_to_html(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8ToHtml(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to html!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}


/*!  @decl string utf8_to_isolat1(string str)
 *!
 */
PIKEFUN string utf8_to_isolat1(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8Toisolat1(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to isolat1!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}

/*! @decl int utf8_check(string str)
 *!
 */
PIKEFUN int utf8_check(string str)
{
  int result;

  result = xmlCheckUTF8(str->str);
  pop_n_elems(args);
  push_int(result);
}

/*! @decl array(int) get_encodings()
 *!
 *! gets the list of available character encoders.
 *!
 *! @returns
 *!  an array of available encoder identifiers.
 *!
 */
PIKEFUN array get_encodings()
{
   int num = 0;
   int cur = 0;
   int upper_limit = 25;
   xmlCharEncodingHandlerPtr encoder;

   for (cur = 0; cur < upper_limit; cur++)
   {
     encoder = xmlGetCharEncodingHandler((xmlCharEncoding)cur);
     if(encoder != NULL)
     {
       push_int(cur);
       num++;
       xmlFree(encoder);
     }
   }
   f_aggregate(num);
   return;  
}

/*! @decl string render_xml(Node n)
 *!   Renders a node tree as an XML string. The entire document tree will 
 *!  be rendered. To render a portion of a tree, use @[Node.render_xml].
 *!
 *!   @param n
 *!     a Node object for a given XML document.
 *!
 */
PIKEFUN string render_xml(object n)
{
  int dumped;
  xmlChar * buf;
  char * str;
  int bufsize;

  CHECK_NODE_PASSED(node);

//  check_node_created();
  if(OBJ2_NODE(n)->object_data->node == NULL)
  { 
    Pike_error("Node not initialized.\n");
  }

  xmlDocDumpFormatMemory(OBJ2_NODE(n)->object_data->node->doc, &buf, &bufsize, 1);

  if(buf!=NULL)
  {
    str = (char *)xmlStrdup(buf);
    xmlFree(buf);
    push_text(str);
  }  
  else
  {
    push_int(0);
  }
}

/*! @decl Node parse_xml(string xml)
 *!   Parse an string containing XML.
 *!
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object parse_xml(string xml)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlReadMemory(xml->str, xml->len, "noname.xml", NULL, 0);
  if(doc == NULL)
  {
    Pike_error("Unable to parse XML.\n");
  }  

  node = xmlDocGetRootElement(doc);
  if(node == NULL)
  {
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
  od->node = node;
}



/*! @decl Node new_xml(string version)
 *!   Create a new XML document with a root node.
 *!
 *!  @param version
 *!     the version of XML to create
 *!  @param root_name
 *!      the name of the root node
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object new_xml(string version, string root_name)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlNewDoc(version->str);

  if(doc == NULL)
  {
    Pike_error("Unable to create new XML document.\n");
  }  
  node = xmlNewNode(NULL, (xmlChar *)root_name->str);
  xmlDocSetRootElement(doc, node);
  if(node == NULL)
  {
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
  od->node = node;
}

/*! @decl Node parse_xslt(string xslt)
 *!   Parse a string containing an XSLT stylesheet.
 *!
 *!  @returns
 *!    a @[Stylesheet] object containing the parsed stylesheet.
 */
PIKEFUN object parse_xslt(string xslt)
{
  struct object * node_obj = NULL;
  xsltStylesheetPtr sty = NULL;
  xmlDocPtr doc = NULL;
  struct Stylesheet_struct * ss;
  STYLESHEET_OBJECT_DATA * od;

  // first, we must parse the xml file. conveniently, we have a function
  // that does that already!
  f_parse_xml(1);

  // we're going to hang on to the node object.
  node_obj = Pike_sp[0-1].u.object;
  add_ref(node_obj);

  doc = OBJ2_NODE(node_obj)->object_data->node->doc;

  if(doc==NULL)
  {
    Pike_error("whoa, horsie! we don't have an xml document!\n");
  }

  sty = xsltParseStylesheetDoc(doc);

  if(sty == NULL)
  {
    Pike_error("Unable to parse stylesheet node.\n");
  }  

  // ok, we have a parsed sheet. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Stylesheet", 0);
  
  ss = OBJ2_STYLESHEET((Pike_sp[0-1].u.object));
  od = (STYLESHEET_OBJECT_DATA *)(ss->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;

  /* TODO: not sure if this is a leak, but we need it to prevent the 
     xmlNode from being freed a second time at the pike Node's destruction  
     (the Stylesheet will free that itself. Note that this is a tricky 
     subject... since the two are linked, perhaps we should call 
     Node.destroy() when the Stylesheet is destroyed... */
  *(OBJ2_NODE(node_obj)->object_data->refs)++;
  od->stylesheet = sty;
  ss->node = node_obj;
}


EXTRA
{
  add_string_constant("__version", "1.12", 0);
  add_string_constant("__author", "Bill Welliver <bill@welliver.org>", 0);

}

void pike_init_xml2_main()
{
  INIT
  LIBXML_TEST_VERSION
}

void pike_exit_xml2_main()
{
  EXIT
  
#ifdef HAVE_XSLT
xsltCleanupGlobals();
#endif /* HAVE_XSLT */

  xmlCleanupParser();
}

/*! @endmodule
 */

/*! @endmodule
 */

/*! @endmodule
 */


