/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: XML2.cmod,v 1.73 2005-05-08 04:29:48 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 *
 */

#include "xml2.h"

  int docloader_num = -1;

/*! @module Public
 */

/*! @module Parser
 */

/*! @module XML2
 */

/*
  
    start of Public.Parser.XML2 module functions

*/

PIKEVAR function docloader
  optflags ID_STATIC;
CVAR PARSER_OBJECT_DATA * object_data;

PIKEFUN void create()
{
  THIS->object_data->docloader_num = docloader_num;

}

/*! @decl array(Node) select_xpath_nodes(string xpath, object node)
 *!
 *! selects nodes based on an XPath query and returns the result.
 */
PIKEFUN array select_xpath_nodes(string xpath, object node)
{
  xmlXPathContextPtr xpathCtx;
  xmlXPathObjectPtr xpathObj;
  xmlNodeSetPtr set;
  xmlNodePtr xn;
  struct object * o;
  int num_nodes = 0;

  CHECK_NODE_PASSED(node);

//  check_node_created();
  if(OBJ2_NODE(node)->object_data->node == NULL)
  { 
    pop_n_elems(2);
    Pike_error("Node not initialized.\n");
  }

  xpathCtx = xmlXPathNewContext(OBJ2_NODE(node)->object_data->node->doc);
  if(xpathCtx == NULL)
  {
    pop_n_elems(2);
    Pike_error("Unable to create new XPath context.\n");
  }
  xpathObj = xmlXPathEvalExpression((xmlChar *)xpath->str, xpathCtx);
  if(xpathObj == NULL) {  
    pop_n_elems(2);
    xmlXPathFreeContext(xpathCtx);
    Pike_error("Unable to evaluate the XPath expression.\n");
  }

  /* now we should generate an array from the node set. */
  set = xpathObj->nodesetval;


  if(set == NULL)
  {
    pop_n_elems(2);
    push_int(0);
    xmlXPathFreeContext(xpathCtx);
    xmlXPathFreeObject(xpathObj);
    return;
  }  

  pop_n_elems(2);

  if(set->nodeNr > 0)
  {
  xn = set->nodeTab[0];
    if(xn != NULL && set->nodeNr > 0) do
    {
      struct Node_struct * ns;
      NODE_OBJECT_DATA * od;

      apply(Pike_fp->current_object, "Node", 0);
      ns = OBJ2_NODE((Pike_sp[0-1].u.object));
      od = (NODE_OBJECT_DATA *)(ns->object_data);

      od->node=xn;
      od->refs = OBJ2_NODE(node)->object_data->refs;
    
      (* od->refs)++;

      num_nodes++;
      xn = set->nodeTab[num_nodes];
    } 
    while (((num_nodes +1) <= set->nodeNr) && xn != NULL);


    if(num_nodes>0) {
      f_aggregate(num_nodes);
    }
  }
  else push_int(0);

  xmlXPathFreeContext(xpathCtx);
  xmlXPathFreeObject(xpathObj);

  return;
}

/*! @decl void set_xslt_docloader(function f) 
 *!
 *! sets the xslt loader function. this is global for the process.
 *!
 *! the callout should have the following signature:
 *!
 *!  Node f(string uri, int options, int type)
 *!
 *!  where: 
 *!    uri is the URI of the document to load
 *!    options are a set of xmlParserOption
 *!    the xsltLoadType indicating the kind of loading required
 */
PIKEFUN void set_xslt_docloader(function f)
{
  assign_svalue(&(THIS->docloader), f);
#ifdef HAVE_XSLTSETLOADERFUNC
#else
  Pike_error("set_docloader not available. upgrade your libxslt.\n");
#endif
}

/*! @decl void clear_xslt_docloader()
 *!
 *! clears the system wide docloader callout, if one was set.
 *!
 */
PIKEFUN void clear_xslt_docloader()
{
  push_int(0);
  assign_svalue(&(THIS->docloader), Pike_sp-1);
  pop_stack();
#ifdef HAVE_XSLTSETLOADERFUNC
#else
  Pike_error("set_docloader not available. upgrade your libxslt.\n");
#endif
}

/*! @decl void set_xml_parser_options(int options)
 *!
 *! sets parser options. 
 *! 
 *! @param options
 *!   a bitwise or of @[Public.Parser.XML2.Constants] options 
 *!   where valid options start with PARSE_. 
 */
PIKEFUN void set_xml_parser_options(int options)
{
  THIS->object_data->xml_parser_options = options;
  pop_stack();
}

/*! @decl void set_html_parser_options(int options)
 *!
 *! sets parser options. 
 *! 
 *! @param options
 *!   a bitwise or of @[Public.Parser.XML2.Constants] options 
 *!   where valid options start with PARSE_. 
 */
PIKEFUN void set_html_parser_options(int options)
{
  THIS->object_data->html_parser_options = options;
  pop_stack();
}

/*! @decl int substituteEntitiesDefault(int def)
 */
PIKEFUN int substituteEntitiesDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  xmlSubstituteEntitiesDefault(def);

  push_int(def);
}

/* @decl int keepBlanksDefault(int def)
 */
PIKEFUN int keepBlanksDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  push_int(xmlKeepBlanksDefault(def));
}

/*!  @decl string utf8_to_html(string str)
 *!
 */
PIKEFUN string utf8_to_html(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8ToHtml(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to html!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}


/*!  @decl string utf8_to_isolat1(string str)
 *!
 */
PIKEFUN string utf8_to_isolat1(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8Toisolat1(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to isolat1!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}

/*! @decl int utf8_check(string str)
 *!
 */
PIKEFUN int utf8_check(string str)
{
  int result;

  result = xmlCheckUTF8(str->str);
  pop_n_elems(args);
  push_int(result);
}

/*! @decl array(int) get_encodings()
 *!
 *! gets the list of available character encoders.
 *!
 *! @returns
 *!  an array of available encoder identifiers.
 *!
 */
PIKEFUN array get_encodings()
{
   int num = 0;
   int cur = 0;
   int upper_limit = 25;
   xmlCharEncodingHandlerPtr encoder;

   for (cur = 0; cur < upper_limit; cur++)
   {
     encoder = xmlGetCharEncodingHandler((xmlCharEncoding)cur);
     if(encoder != NULL)
     {
       push_int(cur);
       num++;
       xmlFree(encoder);
     }
   }
   f_aggregate(num);
   return;  
}

/*!  @decl string get_encoding_name(int e)
 *!
 */
PIKEFUN string get_encoding_name(int e)
{
  const char * enc = NULL;

  enc = xmlGetCharEncodingName(e);

  if(enc != NULL)
    push_text(enc);

  else 
     push_int(0);
}

/*!  @decl string get_encoding_alias(string e)
 *!
 */
PIKEFUN string get_encoding_alias(string e)
{
  const char * enc = NULL;

  enc = xmlGetEncodingAlias(e->str);

  if(enc != NULL)
    push_text(enc);
  else 
     push_int(0);
}

/*! @decl string render_xml(Node n)
 *!   Renders a node tree as an XML string. The entire document tree will 
 *!  be rendered. To render a portion of a tree, use @[Node.render_xml].
 *!
 *!   @param n
 *!     a Node object for a given XML document.
 *!
 */
PIKEFUN string render_xml(object n)
{
  int dumped;
  xmlChar * buf;
  char * str;
  int bufsize;

  CHECK_NODE_PASSED(n);

//  check_node_created();
  if(OBJ2_NODE(n)->object_data->node == NULL)
  { 
    Pike_error("Node not initialized.\n");
  }

  xmlDocDumpFormatMemory(OBJ2_NODE(n)->object_data->node->doc, &buf, &bufsize, 1);

  if(buf!=NULL)
  {
    str = (char *)xmlStrdup(buf);
    xmlFree(buf);
    push_text(str);
  }  
  else
  {
    push_int(0);
  }
}

/*! @decl string render_html(Node n)
 *!   Renders a node tree as an HTML string. The entire document tree will 
 *!  be rendered. To render a portion of a tree, use @[Node.render_html].
 *!
 *!   @param n
 *!     a Node object for a given HTML document.
 *!
 */
PIKEFUN string render_html(object n)
{
  int dumped;
  xmlChar * buf;
  char * str;
  int bufsize;

  CHECK_NODE_PASSED(n);

//  check_node_created();
  if(OBJ2_NODE(n)->object_data->node == NULL)
  { 
    Pike_error("Node not initialized.\n");
  }

  htmlDocDumpMemory(OBJ2_NODE(n)->object_data->node->doc, &buf, &bufsize, 1);

  if(buf!=NULL)
  {
    str = (char *)xmlStrdup(buf);
    xmlFree(buf);
    push_text(str);
  }  
  else
  {
    push_int(0);
  }
}

void my_generic_error(void * userData, xmlErrorPtr error)
{
  char err[255];

  snprintf(err, 255, "Public.Parser.XML error: %d, message: %s", 
             error->level, error->message);
  push_text(err);

  f_werror(1);
}

/*! @decl Node recover_xml(string xml)
 *!   Parse an string containing XML, even if it is not Well Formed.
 *!  @param xml
 *!   String containing XML data to parse.
 *!
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object parse_xml_force(string xml)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlRecoverMemory(xml->str, xml->len);

  if(doc == NULL)
  {
    pop_n_elems(2);
    Pike_error("Unable to parse XML.\n");
  }  

  node = xmlDocGetRootElement(doc);
  if(node == NULL)
  {
    pop_n_elems(2);
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_n_elems(2);

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
  od->node = node;
}

xmlParserInputPtr my_entity_loader(const char * URL, const char * ID,
   xmlParserCtxtPtr context)
{
  printf("request for entity %s\n", URL);
  return NULL; 
}

/*! @decl Node parse_xml(string xml, string|void name, string|void encoding)
 *!   Parse an string containing XML.
 *!  @param xml
 *!   String containing XML data to parse.
 *!  @param name
 *!   String containing name/URI of file.
 *!
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object parse_xml(string xml, string name, string encoding)
{
  xmlDocPtr doc;

  entity_loader = my_entity_loader;

  //  xmlSetExternalEntityLoader(entity_loader);

  generic_handler = my_generic_error;
  // xmlSetStructuredErrorFunc((void *)err_ctx, generic_handler);

  doc = xmlReadMemory(xml->str, xml->len, name->str, 
                      (const char *)encoding->str, 
                      THIS->object_data->xml_parser_options);

  handle_parsed_tree(doc);
}

void handle_parsed_tree(xmlDocPtr doc)
{
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;
  char * err_ctx = "parse_xml";

  if(doc == NULL)
  {
    pop_n_elems(3);
    Pike_error("Unable to parse XML.\n");
  }  

  node = xmlDocGetRootElement(doc);
  if(node == NULL)
  {
    pop_n_elems(3);
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_n_elems(3);

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
  od->node = node;
}

PIKEFUN object parse_xml(string xml, string name)
{
  xmlDocPtr doc;

  entity_loader = my_entity_loader;

  //  xmlSetExternalEntityLoader(entity_loader);

  generic_handler = my_generic_error;

  //xmlSetStructuredErrorFunc((void *)err_ctx, generic_handler);

  doc = xmlReadMemory(xml->str, xml->len, name->str, 
                      NULL, 
                      THIS->object_data->xml_parser_options);

  handle_parsed_tree(doc);
  
}

PIKEFUN object parse_xml(string xml)
{
  push_text("noname.xml");
  f_parse_xml(2);
}

/*! @decl Node parse_html(string html, string|void name, string|void encoding)
 *!   Parse an string containing HTML.
 *!  @param html
 *!   String containing HTML data to parse.
 *!  @param name
 *!   String containing name/URI of file.
 *!
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object parse_html(string html, string name, string encoding)
{
  xmlDocPtr doc;

  entity_loader = my_entity_loader;

  //  xmlSetExternalEntityLoader(entity_loader);

  generic_handler = my_generic_error;
  // xmlSetStructuredErrorFunc((void *)err_ctx, generic_handler);

  doc = htmlReadMemory(html->str, html->len, name->str, 
                      (const char *)encoding->str, 
                      THIS->object_data->html_parser_options);

  handle_parsed_tree(doc);
}

PIKEFUN object parse_html(string html, string name)
{
  xmlDocPtr doc;

  entity_loader = my_entity_loader;

  //  xmlSetExternalEntityLoader(entity_loader);

  generic_handler = my_generic_error;
  // xmlSetStructuredErrorFunc((void *)err_ctx, generic_handler);

  doc = htmlReadMemory(html->str, html->len, name->str, 
                      NULL, 
                      THIS->object_data->html_parser_options);

  handle_parsed_tree(doc);
  
}

PIKEFUN object parse_html(string html)
{
  push_text("noname.html");
  f_parse_html(2);
}

/*! @decl Node new_xml(string version)
 *!   Create a new XML document with a root node.
 *!
 *!  @param version
 *!     the version of XML to create
 *!  @param root_name
 *!      the name of the root node
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object new_xml(string version, string root_name)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlNewDoc(version->str);

  if(doc == NULL)
  {
    Pike_error("Unable to create new XML document.\n");
  }  
  node = xmlNewNode(NULL, (xmlChar *)root_name->str);
  xmlDocSetRootElement(doc, node);
  if(node == NULL)
  {
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
  od->node = node;
}

/*! @decl Node parse_xslt(string xslt, string|void name)
/*! @decl Node parse_xslt(Node xslt)
 *!   Parse a string containing an XSLT stylesheet.
 *!
 *!  @param name
 *!   String containing name/URI of file.
 *!
 *!  @returns
 *!    a @[Stylesheet] object containing the parsed stylesheet.
 */
PIKEFUN object parse_xslt(string xslt)
{
  push_text("noname.xsl");
  f_parse_xslt(2);
}

PIKEFUN object parse_xslt(object xslt)
{
  CHECK_NODE_PASSED(xslt);

  handle_parse_stylesheet();

}

PIKEFUN object parse_xslt(string xslt, string name)
{
  // first, we must parse the xml file. conveniently, we have a function
  // that does that already!
  f_parse_xml(2);

  handle_parse_stylesheet();
}

void handle_parse_stylesheet()
{
  struct object * node_obj = NULL;
  xsltStylesheetPtr sty = NULL;
  xmlDocPtr doc = NULL;
  struct Stylesheet_struct * ss;
  STYLESHEET_OBJECT_DATA * od;

  // we're going to hang on to the node object.
  node_obj = Pike_sp[0-1].u.object;
  add_ref(node_obj);

  doc = OBJ2_NODE(node_obj)->object_data->node->doc;

  if(doc==NULL)
  {
    Pike_error("whoa, horsie! we don't have an xml document!\n");
  }

  sty = xsltParseStylesheetDoc(doc);

  if(sty == NULL)
  {
    Pike_error("Unable to parse stylesheet node.\n");
  }  

  // ok, we have a parsed sheet. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Stylesheet", 0);
  
  ss = OBJ2_STYLESHEET((Pike_sp[0-1].u.object));
  od = (STYLESHEET_OBJECT_DATA *)(ss->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;

  /* TODO: not sure if this is a leak, but we need it to prevent the 
     xmlNode from being freed a second time at the pike Node's destruction  
     (the Stylesheet will free that itself. Note that this is a tricky 
     subject... since the two are linked, perhaps we should call 
     Node.destroy() when the Stylesheet is destroyed... */
  *(OBJ2_NODE(node_obj)->object_data->refs)++;
  od->stylesheet = sty;
  ss->node = node_obj;
}

EXTRA
{
  struct pike_string * ps;
  char * err_ctx = "parse_xml";

  add_string_constant("__version", "1.16", 0);
  add_string_constant("__author", "Bill Welliver <bill@welliver.org>", 0);

  generic_handler = my_generic_error;
  xmlSetStructuredErrorFunc((void *)err_ctx, generic_handler);


  pike_init_xml2_constants();
  pike_init_xml2_node();
  pike_init_xml2_sax();
  pike_init_xml2_stylesheet();
  pike_init_xml2_xmlreader();

  MAKE_CONST_STRING(ps, "docloader");
  docloader_num = isidentifier(ps);

}

INIT
{
  PARSER_OBJECT_DATA * dta;

  dta = (PARSER_OBJECT_DATA*)malloc(sizeof(PARSER_OBJECT_DATA));
  if(dta == NULL)
  {
    Pike_error("xml2_init: unable to allocate memory.\n");
  }

  dta->xml_parser_options = 0;
  dta->html_parser_options = 0;
  THIS->object_data = dta;
 
  LIBXML_TEST_VERSION
}

EXIT
{

  pike_exit_xml2_xmlreader();
  pike_exit_xml2_stylesheet();
  pike_exit_xml2_sax();
  pike_exit_xml2_node();
  pike_exit_xml2_constants();
  
#ifdef HAVE_XSLT
xsltCleanupGlobals();
#endif /* HAVE_XSLT */

  xmlCleanupParser();
}

/*! @endmodule
 */

/*! @endmodule
 */

/*! @endmodule
 */


