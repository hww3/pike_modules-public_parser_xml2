/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: XML2.cmod,v 1.34 2005-04-02 18:32:37 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 *
 */

/*! @module Public
 */

/*! @module Parser
 */

/*! @module XML2
 */

#define _GNU_SOURCE

#include "xml2_config.h"
#include "util.h"

#ifdef HAVE_XML2
#endif /* HAVE_XML2 */

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifdef HAVE_LIBXML_PARSER_H
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#endif

#ifdef HAVE_LIBXML_TREE_H
#include <libxml/tree.h>
#endif

#ifdef HAVE_LIBXML_SAX_H
#include <libxml/SAX.h>
#endif

#ifdef HAVE_LIBXML_XPATH_H
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
#endif

#define CB_INTERNALSUBSET 0
#define CB_ISSTANDALONE 1
#define CB_HASINTERNALSUBSET 2
#define CB_HASEXTERNALSUBSET 3
#define CB_RESOLVEENTITY 4
#define CB_GETENTITY 5
#define CB_ENTITYDECL 6
#define CB_NOTATIONDECL 7
#define CB_ATTRIBUTEDECL 8
#define CB_ELEMENTDECL 9
#define CB_UNPARSEDENTITYDECL 10
#define CB_SETDOCUMENTLOCATOR 11
#define CB_STARTDOCUMENT 12
#define CB_ENDDOCUMENT 13
#define CB_STARTELEMENT 14
#define CB_ENDELEMENT 15
#define CB_REFERENCE 16
#define CB_CHARACTERS 17
#define CB_IGNORABLEWHITESPACE 18
#define CB_PROCESSINGINSTRUCTION 19
#define CB_COMMENT 20
#define CB_WARNING 21
#define CB_ERROR 22
#define CB_FATALERROR 23
#define CB_GETPARAMETERENTITY 24
#define CB_CDATABLOCK 25
#define CB_EXTERNALSUBSET 26
#define CB_STARTELEMENTNS 27
#define CB_ENDELEMENTNS 28
#define CB_SERROR 29

/*
  void my_startElementNs(void * ctx, const xmlChar * localname, 
    const xmlChar * prefix, const xmlChar * uri, 
    int nb_namespaces, const xmlChar ** namespaces, 					 
    int nb_attributes, int nb_defaulted,
    const xmlChar ** atts);
*/

  void my_serror(void * ctx, xmlErrorPtr error);
  void my_entityDecl(void * ctx, const xmlChar * name, int type, const xmlChar * publicId, const xmlChar * systemId, xmlChar * content);
  void my_unparsedEntityDecl(void * ctx, const xmlChar * name, const xmlChar * publicId, const xmlChar * systemId, const xmlChar * notationName);
  void my_attributeDecl(void * ctx, const xmlChar * elem, const xmlChar* fullname, int type, int def, const xmlChar * defaultValue, xmlEnumerationPtr tree);
  void my_elementDecl(void * ctx, const xmlChar * name, int type, xmlElementContentPtr content);
  void my_startElement(void * ctx, const xmlChar * fullname, const xmlChar ** atts);
  void my_comment(void * ctx, const xmlChar * name);
  void my_characters(void * ctx, const xmlChar * ch, int len);
  void my_cdataBlock(void * ctx, const xmlChar * ch, int len);
  void my_ignorableWhitespace(void * ctx, const xmlChar * ch, int len);
  void my_processingInstruction(void * ctx, const xmlChar * target, const xmlChar * data);
  void my_internalSubset(void * ctx, const xmlChar * name, const xmlChar * ExternalID, const xmlChar * SystemID);
  void my_externalSubset(void * ctx, const xmlChar * name, const xmlChar * ExternalID, const xmlChar * SystemID);
  void my_notationDecl(void * ctx, const xmlChar * name, const xmlChar * publicId, const xmlChar * systemId);
  void my_reference(void * ctx, const xmlChar * name);
  void my_endElement(void * ctx, const xmlChar * name);
  int my_hasInternalSubset(void * data);
  int my_hasExternalSubset(void * data);
  void my_startDocument(void * data);
  void my_endDocument(void * data);
  int my_isStandalone(void * data);
  void  make_PSAX_handler();
  struct array * get_callback_data(struct object * o);
  struct svalue * get_callback_func(struct object * o);



  typedef struct
  {
    xmlSAXHandlerPtr sax;
    struct array * handlers;
    xmlParserCtxtPtr context;
  } SAX_OBJECT_DATA;

  typedef struct
  {
    xmlNodePtr node;
    INT32 * refs;
  } NODE_OBJECT_DATA;

#define mySAX THIS->object_data->sax

#define MY_NODE (THIS->object_data->node)

#define NEW_NODE_OBJ(_X_, _Y_) { apply(Pike_fp->current_object, "Node", 0); \
  OBJ2_NODE((Pike_sp[0-1].u.object))->object_data->node = _Y_; \
  _X_ = Pike_sp[0-1].u.object; pop_stack(); }
#define NEW_NODE_OBJ_REFS(o)    OBJ2_NODE(o)->object_data->refs = THIS->object_data->refs; \
    (* OBJ2_NODE(o)->object_data->refs) ++;

#define NEW_NODE() clone_object(Node_program, 0)
#define NEW_NODE_REFS(o)  OBJ2_NODE(o)->object_data->refs = THIS->object_data->refs; \
      (* OBJ2_NODE(o)->object_data->refs)++; 

/*! @class SAX
 *!
 *!  a SAX v1 parser featuring both pull and push (chunked) parsing.
 *!
 */
PIKECLASS SAX
{
  CVAR SAX_OBJECT_DATA * object_data;


  void PSAX_plain_callback(int callback_id, void * data)
  {
    int z = 0;

    if(ITEM(THIS->object_data->handlers)[callback_id].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int retval;

       o = ITEM(THIS->object_data->handlers)[callback_id].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+1)], a->size);
    }    
  }

  void PSAX_string_len_callback(int cb_type, void * ctx, const xmlChar * ch, int len)
  {
    if(ITEM(THIS->object_data->handlers)[cb_type].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[cb_type].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)ch);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+2)], a->size + 1);
    }    
  }

  int PSAX_plain_int_callback(int callback_id, void * data)
  {
    int retval;
    int z = 0;

    if(ITEM(THIS->object_data->handlers)[callback_id].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;

       o = ITEM(THIS->object_data->handlers)[callback_id].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+1)], a->size);
       retval = Pike_sp[0-1].u.integer;       
       pop_stack();
       return retval;
    }    
    return 0;
  }

  void my_serror(void * ctx, xmlErrorPtr error)
  {
    if(ITEM(THIS->object_data->handlers)[CB_SERROR].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_SERROR].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text("domain");
       push_int(error->domain);
       push_text("code");
       push_int(error->code);
       push_text("message");
       push_text((char *)error->message);
       push_text("level");
       push_int(error->level);
       push_text("line");
       push_int(error->line);
       push_text("column");
       push_int(error->int2);

       f_aggregate_mapping(12);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+2)], a->size + 1);
    }        
  }

  void my_entityDecl(void * ctx, const xmlChar * name, int type, const xmlChar * publicId, const xmlChar * systemId, xmlChar * content)
  {
    if(ITEM(THIS->object_data->handlers)[CB_ENTITYDECL].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_ENTITYDECL].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_int(type);
       push_text((char *)publicId);
       push_text((char *)systemId);
       push_text((char *)content);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+6)], a->size + 5);
    }    
  }

  void my_elementDecl(void * ctx, const xmlChar * name, int type, xmlElementContentPtr content)
  {
    if(ITEM(THIS->object_data->handlers)[CB_ELEMENTDECL].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_ELEMENTDECL].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_int(type);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+3)], a->size + 2);
    }    
  }

  void my_unparsedEntityDecl(void * ctx, const xmlChar * name, const xmlChar * publicId, const xmlChar * systemId, const xmlChar * notationName)
  {
    if(ITEM(THIS->object_data->handlers)[CB_UNPARSEDENTITYDECL].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_UNPARSEDENTITYDECL].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_text((char *)publicId);
       push_text((char *)systemId);
       push_text((char *)notationName);
       
       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+5)], a->size + 4);
    }    
  }

  void my_attributeDecl(void * ctx, const xmlChar * elem, const xmlChar* fullname, int type, int def, const xmlChar * defaultValue, xmlEnumerationPtr tree)
  {
    if(ITEM(THIS->object_data->handlers)[CB_ATTRIBUTEDECL].type!=PIKE_T_INT)
    {
       xmlEnumerationPtr p;
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_ATTRIBUTEDECL].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)elem);
       push_text((char *)fullname);
       push_int(type);
       push_int(def);
       push_text((char *)defaultValue);
       
       if(tree!=NULL)
       {
         for(p = tree; p->next != NULL; p = p->next)
         {
           push_text((char *) p->name);
           z++;
         }
       }

       f_aggregate(z);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+6)], a->size + 5);
    }    
  }

  void my_notationDecl(void * ctx, const xmlChar * name, const xmlChar * publicId, const xmlChar * systemId)
  {
    if(ITEM(THIS->object_data->handlers)[CB_NOTATIONDECL].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_NOTATIONDECL].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_text((char *)publicId);
       push_text((char *)systemId);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+4)], a->size + 3);
    }    
  }

  void my_internalSubset(void * ctx, const xmlChar * name, const xmlChar * ExternalID, const xmlChar * SystemID)
  {
    if(ITEM(THIS->object_data->handlers)[CB_INTERNALSUBSET].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_INTERNALSUBSET].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_text((char *)ExternalID);
       push_text((char *)SystemID);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+4)], a->size + 3);
    }    
  }

  void my_externalSubset(void * ctx, const xmlChar * name, const xmlChar * ExternalID, const xmlChar * SystemID)
  {
    if(ITEM(THIS->object_data->handlers)[CB_EXTERNALSUBSET].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_EXTERNALSUBSET].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);
       push_text((char *)ExternalID);
       push_text((char *)SystemID);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+4)], a->size + 3);
    }    
  }

  void my_processingInstruction(void * ctx, const xmlChar * target, const xmlChar * data)
  {
    if(ITEM(THIS->object_data->handlers)[CB_PROCESSINGINSTRUCTION].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_PROCESSINGINSTRUCTION].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)target);
       push_text((char *)data);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+3)], a->size + 2);
    }    
  }

  void my_endElement(void * ctx, const xmlChar * name)
  {
    if(ITEM(THIS->object_data->handlers)[CB_ENDELEMENT].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_ENDELEMENT].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+2)], a->size + 1);
    }    
  }

  void my_cdataBlock(void * ctx, const xmlChar * ch, int len)
  {
    PSAX_string_len_callback(CB_CDATABLOCK, ctx, ch, len);
  }

  void my_ignorableWhitespace(void * ctx, const xmlChar * ch, int len)
  {
    PSAX_string_len_callback(CB_IGNORABLEWHITESPACE, ctx, ch, len);
  }

  void my_characters(void * ctx, const xmlChar * ch, int len)
  {
    PSAX_string_len_callback(CB_CHARACTERS, ctx, ch, len);
  }

  void my_reference(void * ctx, const xmlChar * name)
  {
    if(ITEM(THIS->object_data->handlers)[CB_REFERENCE].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_REFERENCE].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+2)], a->size + 1);
    }    
  }

  void my_comment(void * ctx, const xmlChar * value)
  {
    if(ITEM(THIS->object_data->handlers)[CB_COMMENT].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;
       int z = 0;

       o = ITEM(THIS->object_data->handlers)[CB_COMMENT].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)value);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+2)], a->size + 1);
    }    
  }

  void my_startElement(void * data, const xmlChar * name, const xmlChar ** atts)
  {
    int z = 0;

    if(ITEM(THIS->object_data->handlers)[CB_STARTELEMENT].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;

       o = ITEM(THIS->object_data->handlers)[CB_STARTELEMENT].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)name);

       if(atts!= NULL)
       {
         for(z=0; atts[z] != NULL; z++)

         {
            push_text(atts[z]);
         }
       }
         f_aggregate_mapping(z);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+3)], a->size + 2);
/*       printf("finished callback.\n"); */
    }    
  }

/* This function is for the SAX2 interface, which we can't seem 
    to figure out yet.
 */
  void my_startElementNs(void * ctx, const xmlChar * localname, 
    const xmlChar * prefix, const xmlChar * uri, 
    int nb_namespaces, const xmlChar ** namespaces, 					 
    int nb_attributes, int nb_defaulted,
    const xmlChar ** atts)
  {
    int z = 0;
    if(ITEM(THIS->object_data->handlers)[CB_STARTELEMENTNS].type!=PIKE_T_INT)
    {
       struct svalue * func;
       struct array * a;
       struct object * o;

       o = ITEM(THIS->object_data->handlers)[CB_STARTELEMENTNS].u.object;
       a = get_callback_data(o);       
       func = get_callback_func(o);       
       push_svalue(func);

       push_text((char *)localname);
       push_text((char *)prefix);
       push_text((char *)uri);

       if(atts!= NULL)
       {
         for(z=0; atts[z] != NULL; z++)

         {
            push_text(atts[z]);
         }
       }
         f_aggregate_mapping(z);

       for(z = 0; z < a->size; z++)
       {
         push_svalue(&ITEM(a)[z]);
       }
       apply_svalue(&Pike_sp[0- (a->size+4)], a->size + 3);
    }    
  }

  int my_isStandalone(void * data)
  {
    int retval = 0;
    PSAX_plain_callback(CB_ISSTANDALONE, data);
    retval = Pike_sp[0-1].u.integer;    
    pop_stack();
    return retval;
  }

  void my_startDocument(void * data)
  {
    printf("start doc!\n");
    PSAX_plain_callback(CB_STARTDOCUMENT, data);
  }

  void my_endDocument(void * data)
  {
    printf("end doc!\n");
    PSAX_plain_callback(CB_ENDDOCUMENT, data);
  }

  int my_hasInternalSubset(void * data)
  {
    return PSAX_plain_int_callback(CB_STARTDOCUMENT, data);
  }

  int my_hasExternalSubset(void * data)
  {
    return PSAX_plain_int_callback(CB_STARTDOCUMENT, data);
  }

/*!  @decl void set_callback(int callback_id, function f, mixed ... extra_args)
 *!
 *!    sets a SAX handler callback function.
 *! 
 *!  @param callback_id
 *!    the id of the type of handler you wish to set. this should be 
 *!    one of the @[Public.Parser.XML2.Constants].SAX_CB_* members.
 *!
 *!  @param f
 *!    the function to call when the selected parsing event occurs.
 *!    prototypes for each event function are found in 
 *!    @[Public.Parser.XML2.SAXHandlers].
 *! 
 *!  @param extra_args
 *!    extra data to supply to the callback function. these will be passed
 *!    as extra parameters after any provided by the parser.
 *!
*!
 *! void serror_cb(mapping(string:mixed) error, mixed ... extra_args);
 *! mapping elements: domain, code, message, level, line, column
 *!
 *! void entitydecl_cb(string name, int type, string publicId, string systemId, string content, mixed ... extra_args);
 *!
 *! void elementdecl_cb(string name, int type, mixed ... extra_args);
 *!
 *! void unparsedentitydecl_cb(string name, string publicId, string systemId, string notationName, mixed ... extra_args);
 *!
 *! void attributedecl_cb(string elem, string fullname, int type, int def, string defaultValue, mixed ... extra_args);
 *!
 *! void notationdecl_cb(string name, string publicId, string systemId, mixed ... extra_args);
 *!
 *! void internalsubset_cb(string name, string ExternalId, string SystemId, mixed ... extra_args);
 *!
 *! void externalsubset_cb(string name, string ExternalId, string SystemId, mixed ... extra_args);
 *!
 *! void processinginstruction_cb(string target, string data, mixed ... extra_args);
 *!
 *! void endelement_cb(string name, mixed ... extra_args);
 *!
 *! void cdatablock_cb(string chars, mixed ... extra_args);
 *!
 *! void ignorablewhitespace(string chars, mixed ... extra_args);
 *!
 *! void characters_cb(string chars, mixed ... extra_args);
 *!
 *! void reference_cb(string name, mixed ... extra_args);
 *!
 *! void comment_cb(string value, mixed ... extra_args);
 *!
 *! void startelement_cb(string name, mapping(string:string) attributes, mixed ... extra_args);
 *!
 *! int isstandalone_cb(mixed ... extra_args);
 *!
 *! void startdocument_cb(mixed ... extra_args);
 *!
 *! void enddocument_cb(mixed ... extra_args);
 *!
 *! int hasinternalsubset(mixed ... extra_args);
 *!
 *! int hasexternalsubset(mixed ... extra_args);
 */
  PIKEFUN void set_callback(int callback_id, function f, mixed ... extra_args)
  {
    struct svalue * ae;
printf("setting callback %d\n", callback_id);

    switch(callback_id)
    {
      case CB_INTERNALSUBSET:
      mySAX->internalSubset = my_internalSubset;
      break;

      case CB_ISSTANDALONE:
      mySAX->isStandalone = my_isStandalone;
      break;

      case CB_HASINTERNALSUBSET:
      mySAX->hasInternalSubset = my_hasInternalSubset;
      break;

      case CB_HASEXTERNALSUBSET:
      mySAX->hasExternalSubset = my_hasExternalSubset;
      break;
  
      case CB_RESOLVEENTITY:
      mySAX->resolveEntity = NULL; 
      break;

      case CB_ENTITYDECL:
      mySAX->entityDecl = my_entityDecl;
      break;

      case CB_NOTATIONDECL:
      mySAX->notationDecl = my_notationDecl;
      break;

      case CB_ATTRIBUTEDECL:
      mySAX->attributeDecl = my_attributeDecl;
      break;

      case CB_ELEMENTDECL:
      mySAX->elementDecl = my_elementDecl;
      break;

      case CB_UNPARSEDENTITYDECL:
      mySAX->unparsedEntityDecl = my_unparsedEntityDecl;
      break;

      case CB_STARTDOCUMENT:
      mySAX->startDocument = my_startDocument;
      break;

      case CB_ENDDOCUMENT:
      mySAX->endDocument = my_endDocument;
      break;

      case CB_STARTELEMENT:
      mySAX->startElement = my_startElement;
      break;

      case CB_ENDELEMENT:
      mySAX->endElement = my_endElement;
      break;

      case CB_REFERENCE:
      mySAX->reference = my_reference;
      break;

      case CB_CHARACTERS:
      mySAX->characters = my_characters;
      break;

      case CB_IGNORABLEWHITESPACE:
      mySAX->ignorableWhitespace = my_ignorableWhitespace;
      break;

      case CB_PROCESSINGINSTRUCTION:
      mySAX->processingInstruction = my_processingInstruction;
      break;

      case CB_COMMENT:
      mySAX->comment = my_comment;
      break;

      case CB_GETPARAMETERENTITY:
      mySAX->getParameterEntity = NULL; 
      break;

      case CB_CDATABLOCK:
      mySAX->cdataBlock = my_cdataBlock;
      break;

      case CB_EXTERNALSUBSET:
      mySAX->externalSubset = my_externalSubset;
      break;

      case CB_STARTELEMENTNS:
      mySAX->startElementNs = NULL;
      break;

      case CB_ENDELEMENTNS:
      mySAX->endElementNs = NULL;
      break;

      case CB_SERROR:
      mySAX->serror = my_serror;
      break;

      default:
      Pike_error("unknown callback identifier.\n");
  } 
    f_aggregate(args-2);

    make_PSAX_handler();

    if(ITEM(THIS->object_data->handlers)[callback_id].type!=PIKE_T_INT)
    {
      ae = &(ITEM(THIS->object_data->handlers)[callback_id]);
      free_svalue(ae);
      push_int(0);
      ITEM(THIS->object_data->handlers)[callback_id] = Pike_sp[0-1];
      ae = &(ITEM(THIS->object_data->handlers)[callback_id]);
      pop_stack();
    }

    // add_ref(f->u.efun);
    (ITEM(THIS->object_data->handlers)[callback_id]) = Pike_sp[0-1];

//    pop_stack();

  }


/*!  @decl int clear_callback(int callback_id)
 *!
 *!  clears a SAX handler callback.
 *!
 *!  @param callback_id
 *!    the id of the type of handler you wish to set. this should be 
 *!    one of the @[Public.Parser.XML2.Constants].SAX_CB_* members.
 *!
 *!  @returns
 *!    1 if the handler existed, 0 otherwise.
 */
  PIKEFUN void clear_callback(int callback_id)
  {
    struct svalue * ae;

    switch(callback_id)
    {
      case CB_INTERNALSUBSET:
      mySAX->internalSubset = NULL;
      break;

      case CB_ISSTANDALONE:
      mySAX->isStandalone = NULL;
      break;

      case CB_HASINTERNALSUBSET:
      mySAX->hasInternalSubset = NULL;
      break;

      case CB_HASEXTERNALSUBSET:
      mySAX->hasExternalSubset = NULL;
      break;
  
      case CB_RESOLVEENTITY:
      mySAX->resolveEntity = NULL; /* TODO: needs more thought. */
      break;

      case CB_ENTITYDECL:
      mySAX->entityDecl = NULL;
      break;

      case CB_NOTATIONDECL:
      mySAX->notationDecl = NULL;
      break;

      case CB_ATTRIBUTEDECL:
      mySAX->attributeDecl = NULL;
      break;

      case CB_ELEMENTDECL:
      mySAX->elementDecl = NULL;
      break;

      case CB_UNPARSEDENTITYDECL:
      mySAX->unparsedEntityDecl = NULL;
      break;

      case CB_STARTDOCUMENT:
      mySAX->startDocument = NULL;
      break;

      case CB_ENDDOCUMENT:
      mySAX->endDocument = NULL;
      break;

      case CB_STARTELEMENT:
      mySAX->startElement = NULL;
      break;

      case CB_ENDELEMENT:
      mySAX->endElement = NULL;
      break;

      case CB_REFERENCE:
      mySAX->reference = NULL;
      break;

      case CB_CHARACTERS:
      mySAX->characters = NULL;
      break;

      case CB_IGNORABLEWHITESPACE:
      mySAX->ignorableWhitespace = NULL;
      break;

      case CB_PROCESSINGINSTRUCTION:
      mySAX->processingInstruction = NULL;
      break;

      case CB_COMMENT:
      mySAX->comment = NULL;
      break;

      case CB_GETPARAMETERENTITY:
      mySAX->getParameterEntity = NULL; /* TODO: needs more thought. */
      break;

      case CB_CDATABLOCK:
      mySAX->cdataBlock = NULL;
      break;

      case CB_EXTERNALSUBSET:
      mySAX->externalSubset = NULL;
      break;

      case CB_STARTELEMENTNS:
      mySAX->startElementNs = NULL;
      break;

      case CB_ENDELEMENTNS:
      mySAX->endElementNs = NULL;
      break;

      case CB_SERROR:
      mySAX->serror = NULL;
      break;

      default:
      Pike_error("unknown callback identifier.\n");
  } 



    if(ITEM(THIS->object_data->handlers)[callback_id].type!=PIKE_T_INT)
    {
      ae = &(ITEM(THIS->object_data->handlers)[callback_id]);
      free_svalue(ae);
      push_int(0);
      ITEM(THIS->object_data->handlers)[callback_id] = Pike_sp[0-1];
      ae = &(ITEM(THIS->object_data->handlers)[callback_id]);
      pop_stack();
    }

    pop_stack();
  }

  PIKEFUN void create()
  {
  }

/*!  @decl int feed(string d)
 *!
 *!  feed some XML data to the parser. @[feed] may be called multiple
 *!   times to pass an entire XML document to the parser. The document
 *!   will be processed as data is fed to the parser.
 *!
 *!  @param d
 *!    some XML data to be parsed. need not be a complete XML document.
 *!
 *!  @returns
 *!   the number of bytes processed.
 */
  PIKEFUN int feed(string d)
  {
    int retval;
    xmlParserCtxtPtr context;

    if(THIS->object_data->context == NULL)
    {

      context = xmlCreatePushParserCtxt(mySAX, NULL, NULL, 0, NULL);
      if(context == NULL) Pike_error("unable to create parser context.\n");
      THIS->object_data->context = context;
    } 

    retval = xmlParseChunk(THIS->object_data->context, d->str, d->len, 0);
    push_int(retval);
  }

/*!  @decl int end()
 *! 
 *!  end parsing of a document and prepare for the next document.
 *!
 *!  resets the document parsing context and prepares for the next 
 *!  document. @[end] should be called after the last chunk of data 
 *!  in an XML document has been passed to @[feed]. 
 */ 
  PIKEFUN int end()
  {
    int retval;
    xmlParserCtxtPtr context;
    char * b = "foo";

    if(THIS->object_data->context == NULL)
    {

      context = xmlCreatePushParserCtxt(mySAX, NULL, NULL, 0, NULL);
      if(context == NULL) Pike_error("unable to create parser context.\n");
      THIS->object_data->context = context;
    } 

    retval = xmlParseChunk(THIS->object_data->context, b, 0, 1);
    push_int(retval);

    THIS->object_data->context = NULL;
  }

/*!  @decl int parse(string d)
 *!
 *!  feed a complete XML document to the parser. data from the document
 *!   will be processed and any registered SAX handler callbacks will
 *!   be called as SAX events occur. this method contains an implicit
 *!   call to @[end], so that the context is prepared to receive a new 
 *!   document after this function returns.
 *!
 *!   you may call this method with an (ending) fragment of an XML 
 *!   document, as long as any previous data needed to produce a valid 
 *!   XML document has already been fed to the parser using @[feed]. 
 *!
 *!  @param d
 *!    some XML data to be parsed. need not be a complete XML document.
 *!
 *!  @returns
 *!   the number of bytes processed.
 */
  PIKEFUN int parse(string d)
  {
    int retval;
    xmlParserCtxtPtr context;
    xmlSAXHandlerPtr ySAX;


    if(THIS->object_data->context == NULL)
    {
      context = xmlCreatePushParserCtxt(mySAX, NULL, NULL, 0, NULL);
      if(context == NULL) Pike_error("unable to create parser context.\n");
      THIS->object_data->context = context;
    }


    retval = xmlParseChunk(THIS->object_data->context, d->str, d->len, 0);
    retval = xmlParseChunk(THIS->object_data->context, d->str, 0, 1);

    if(THIS->object_data->context != NULL)
    {
      xmlFreeParserCtxt(THIS->object_data->context);
      THIS->object_data->context=NULL;
    }
    push_int(retval);
  }

  INIT
  {
   SAX_OBJECT_DATA * sax;
   struct array * handlers;
   xmlParserCtxtPtr context;

   sax = malloc(sizeof(SAX_OBJECT_DATA));

   if(sax == NULL) 
     Pike_error("sax_init: out of memory.\n");

   sax->sax = malloc(sizeof(struct _xmlSAXHandler));

   push_int(30);
   f_allocate(1);

   handlers = Pike_sp[0-1].u.array;
   add_ref(handlers);

   sax->handlers = handlers;

   pop_stack();

   THIS->object_data = sax;
   THIS->object_data->context = NULL;


      mySAX->internalSubset = NULL;
      mySAX->isStandalone = NULL;
      mySAX->hasInternalSubset = NULL;
      mySAX->hasExternalSubset = NULL;
      mySAX->resolveEntity = NULL;
      mySAX->entityDecl = NULL;
      mySAX->notationDecl = NULL;
      mySAX->attributeDecl = NULL;
      mySAX->elementDecl = NULL;
      mySAX->unparsedEntityDecl = NULL;
      mySAX->startDocument = NULL;
      mySAX->endDocument = NULL;
      mySAX->startElement = NULL;
      mySAX->endElement = NULL;
      mySAX->reference = NULL;
      mySAX->characters = NULL;
      mySAX->ignorableWhitespace = NULL;
      mySAX->processingInstruction = NULL;
      mySAX->comment = NULL;
      mySAX->setDocumentLocator = NULL;
      mySAX->getParameterEntity = NULL;
      mySAX->getEntity = NULL;
      mySAX->cdataBlock = NULL;
      mySAX->externalSubset = NULL;
      mySAX->startElementNs = NULL;
      mySAX->endElementNs = NULL;
      mySAX->serror = NULL;

    xmlDefaultSAXHandlerInit();
//    context = xmlCreatePushParserCtxt(mySAX, NULL, NULL, 0, NULL);
//    THIS->object_data->context = context;
  }
 
  EXIT
  {
    if(THIS->object_data->context != NULL)
    {
      xmlFreeParserCtxt(THIS->object_data->context);  
    }
    if(THIS->object_data->handlers != NULL)
    {
      int x = 0;
      for(x = 0; x < THIS->object_data->handlers->size; x++)
      {
      free_svalue(&ITEM(THIS->object_data->handlers)[x]);
      }
      free_array(THIS->object_data->handlers);
    }
    if(THIS->object_data)
      free(THIS->object_data);
  }

  PIKECLASS PSAXHandler
  {
    PIKEVAR array user_data;
    PIKEVAR function cb;

    PIKEFUN void create(function cb, array user_data)
    {
      THIS->user_data = user_data;
      add_ref(user_data);    
      assign_svalue(&(THIS->cb), cb);
  //    add_ref(THIS->cb.u.efun);
  //    add_ref(THIS->user_data);
    }
EXIT
{
  printf("PSAXHandler exit\n");
//  free_array(THIS->user_data);
//  free_svalue(& THIS->cb);
}
  }


}

void make_PSAX_handler()
{
  struct object * o;
  
  o = clone_object(SAX_PSAXHandler_program, 2);
  push_object(o);
  add_ref(o);
  return;
}

struct array * get_callback_data(struct object * o)
{
    return OBJ2_SAX_PSAXHANDLER(o)->user_data;
} 
    
struct svalue * get_callback_func(struct object * o)
{
    return &(OBJ2_SAX_PSAXHANDLER(o)->cb);
}     

/*! @endclass 
 *!
 */

/*! @class Node
 */

PIKECLASS Node
optflags ID_PRIVATE
{

  CVAR NODE_OBJECT_DATA   *object_data;

PIKEFUN string _sprintf(int type, mixed t)
{
  char * desc;

  check_node_created();
  if(MY_NODE->name == NULL)
  {
    pop_n_elems(args);
    push_text("Node(UNKNOWN)");
    return;    
  }
  desc = malloc(strlen(MY_NODE->name) + 15);

  if(desc == NULL)
    Pike_error("Unable to allocate memory!\n");

  snprintf(desc, strlen(MY_NODE->name)+15, "Node(%d, %s)", 
    MY_NODE->type, (char *)(MY_NODE->name));

  pop_n_elems(args);
  
  push_text(desc);
}

PIKEFUN void create()
{
}

/*! @decl int get_line_no()
 *! @returns 
 *!   the line number the node is present on
 */
PIKEFUN int get_line_no()
{
  check_node_created();

  push_int(MY_NODE->line);
}

/*! @decl Node set_ns(string ns_prefix)
 *!
 */
PIKEFUN object set_ns(string ns_prefix)
{
  xmlNsPtr ans;
  
  ans = xmlSearchNs(MY_NODE->doc, MY_NODE, (xmlChar *)ns_prefix->str);
  if(ans == NULL)
  {
    Pike_error("Namespace %s does not yet exist.\n", ns_prefix->str);
  }

  xmlSetNs(MY_NODE, ans);

  push_object(this_object());
}

/*! @decl Node set_content(string content)
 *!
 *! sets the content for a node
 *!
 */
PIKEFUN object set_content(string content)
{
  check_node_created();
  xmlNodeSetContent(MY_NODE, (xmlChar *)content->str);
  
  push_object(this_object());

}

/*! @decl string get_text()
 *!
 *! gets the contents of a text node, or the contents and children of an 
 *! element, or the value of an attribute node.
 */
PIKEFUN string get_text()
{
  xmlChar * val;
  check_node_created();
  val = xmlNodeGetContent(MY_NODE);

  if(val == NULL)
    push_int(0);
  else
    push_text(val);
}

/*! @decl string get_node_path()
 *!
 *! returns an XPath/XQuery based path for this Node.
 */
PIKEFUN string get_node_path()
{
  xmlChar * val;
  check_node_created();
  val = xmlGetNodePath(MY_NODE);

  if(val == NULL)
    push_int(0);
  else
    push_text(val);
}

/*! @decl string get_ns()
 *!  returns the default name space uri for the element
 */
PIKEFUN string get_ns()
{
  char * str;

  check_node_created();
  if(MY_NODE->ns != NULL)
  {
    str = xmlStrdup(MY_NODE->ns->href);
    push_text(str);    
  }
  else push_int(0);
}

/*! @decl mapping get_nss()
 *!   gets a list of all known namespaces for this element.
 *! @returns
 *!    a mapping of "short" prefixes to namespace uris.
 */
PIKEFUN mapping get_nss()
{
  xmlNsPtr * list;
  xmlNsPtr  ns;
  int num_ns = 0;

  check_node_created();
  list =  xmlGetNsList(MY_NODE->doc, MY_NODE);

  if(list == NULL)
  {
    push_int(0); 
    return;
  }   

  for(ns = * list; (ns!=NULL); ns = ns->next)
  {
    push_text(ns->prefix);
    push_text(ns->href);
    num_ns++;
  }
  f_aggregate_mapping(num_ns*2);
}

/*! @decl string get_base()
 *!
 */
PIKEFUN string get_base()
{
  xmlChar * val;
  check_node_created();
  val = xmlNodeGetBase(MY_NODE->doc, MY_NODE);

  if(val == NULL)
    push_int(0);
  else
    push_text(val);
}

/*! @decl string get_lang()
 *!
 */
PIKEFUN string get_lang()
{
  xmlChar * val;
  check_node_created();
  val = xmlNodeGetLang(MY_NODE);

  if(val == NULL)
    push_int(0);
  else
    push_text(val);
}

/*! @decl int get_space_preserve()
 *!
 */
PIKEFUN int get_space_preserve()
{
  int i;
  check_node_created();
  i = xmlNodeGetSpacePreserve(MY_NODE);

    push_int(i);
}


/*! @decl mapping get_attributes()
 *!   returns all attributes, irrespective of namespace
 *! @returns
 *!   a mapping of attribute name to attribute value.
 */
PIKEFUN mapping get_attributes()
{
  struct _xmlAttr * attr;
  int num_attrs = 0;

  check_node_created();
  /* only element nodes have attributes. */
  if(MY_NODE->type != XML_ELEMENT_NODE)
  {
    push_int(0);
    return;
  }
  else
  {
    attr = MY_NODE->properties;

    for(attr; attr!=NULL; attr = attr->next)
    {
      xmlChar * val = NULL;
      if(attr==NULL) break;

      val = xmlGetProp(MY_NODE, attr->name);

      if(val == NULL) val = "";

      push_text((char *)(attr->name));
      push_text((char *)(val));

      xmlFree(val);

//      printf("Found a property: %s\n", (char *)(attr->name));
      num_attrs ++;
    }
   
   f_aggregate_mapping(num_attrs*2);

   }
    return;
}

/*! @decl mapping get_no_ns_attributes()
 *!   returns all attributes not present in a namespace
 *! @returns
 *!   a mapping of attribute name to attribute value.
 */
PIKEFUN mapping get_no_ns_attributes()
{
  struct _xmlAttr * attr;
  int num_attrs = 0;

  check_node_created();
  /* only element nodes have attributes. */
  if(MY_NODE->type != XML_ELEMENT_NODE)
  {
    push_int(0);
    return;
  }
  else
  {
    attr = MY_NODE->properties;

    for(attr; attr!=NULL; attr = attr->next)
    {
      xmlChar * val = NULL;
      if(attr==NULL) break;
      if(attr->ns == NULL) continue;

      val = xmlGetNoNsProp(MY_NODE, attr->name);

      if(val != NULL) 
      {
        push_text((char *)(attr->name));
        push_text((char *)(val));
        num_attrs ++;
      }
    }
   
   f_aggregate_mapping(num_attrs*2);

   }
    return;
}

/*! @decl mapping get_ns_attributes(string ns_prefix)
 *!   given a namespace uri, return all elements for that namespace
 *!   present in the element.
 *! @returns
 *!    a mapping of attribute names to attribute values.
 */
PIKEFUN mapping get_ns_attributes(string ns_uri)
{
  struct _xmlAttr * attr;
  int num_attrs = 0;

  check_node_created();
  /* only element nodes have attributes. */
  if(MY_NODE->type != XML_ELEMENT_NODE)
  {
    push_int(0);
    return;
  }
  else
  {
    attr = MY_NODE->properties;

    for(attr; attr!=NULL; attr = attr->next)
    {
      xmlChar * val = NULL;
      xmlNs * ns = NULL;
      if(attr==NULL) break;
      ns = attr->ns;
      if(!strcmp(ns_uri->str, ns->href)) continue;
      val = xmlGetProp(MY_NODE, attr->name);

      if(val == NULL) val = "";

      push_text((char *)(attr->name));
      push_text((char *)(val));
      xmlFree(val);
//      printf("Found a property: %s\n", (char *)(attr->name));
      num_attrs ++;
    }
   
   f_aggregate_mapping(num_attrs*2);

   }
    return;
}

/*!  @decl array children()
 *!     get all children of this node
 *!  @returns
 *!      an array of all elements with are a direct child of this element.
 */
PIKEFUN array children()
optflags OPT_SIDE_EFFECT
{
  struct object * o;
  xmlNode *cur_node = NULL;
  int num_children=0;
  check_node_created();

  if(MY_NODE->children != NULL)
    cur_node = MY_NODE->children;

  for(cur_node; cur_node; cur_node = cur_node->next) {
    if (cur_node != NULL) {
      o = NEW_NODE();
      OBJ2_NODE(o)->object_data->node = cur_node; 
      NEW_NODE_REFS(o);
      push_object(o);
      num_children++;
    }
  }
  if(num_children>0)
    f_aggregate(num_children);
  else push_int(0);
}

/*!  @decl Node parent()
 *!     get the Node which is the parent of this Node.
 */
PIKEFUN object parent()
{
  struct object * o;
  check_node_created();
  if(MY_NODE->parent == NULL)
  {
    push_int(0);
    return;
  }

  else 
  {
    o=NEW_NODE();
    OBJ2_NODE(o)->object_data->node = MY_NODE->parent;
    NEW_NODE_REFS(o);
// printf("refs: %d\n", (* OBJ2_NODE(o)->object_data->refs));
    push_object(o);
  }
}

/*!  @decl Node get_root_node()
 *!     get the Node which is the root of this tree.
 */
PIKEFUN object get_root_node()
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();
  
  node = xmlDocGetRootElement(MY_NODE->doc);
  if(node == NULL)
  {
    push_int(0);
    return;
  }

  else 
  {
    o=NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node set_root_node()
 *!     set this Node to be the root of this tree.
 *!  @returns
 *!     the old root of the tree, if any existed.
 */
PIKEFUN object set_root_node()
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();
  
  node = xmlDocSetRootElement(MY_NODE->doc, MY_NODE);
  if(node == NULL)
  {
    push_int(0);
    return;
  }

  else 
  {
    o=NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node new_cdata_block(string contents)
 *!     returns an unlinked CDATA block.
 */
PIKEFUN object new_cdata_block(string contents)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlNewCDataBlock(MY_NODE->doc, contents->str, contents->len);
  
  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node new_pi(string name, string contents)
 *!     returns a linked Processing Instruction node.
 */
PIKEFUN object new_pi(string name, string contents)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlNewDocPI(MY_NODE->doc, name->str, contents->str);
  
  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node set_attribute(string name, string value)
 *!  @decl Node set_ns_attribute(string name, string ns, string value)
 *!
 *!  sets a new attribute, overwriting any existing value.
 *!  if @[value] is zero, the attribute will be removed from the node.
 */
PIKEFUN object set_ns_attribute(string name, string ns, string value)
{
  struct object * o;
  xmlAttrPtr attr;
  xmlNsPtr ans;

printf("called ns version\n");

  check_node_created();

  ans = xmlSearchNs(MY_NODE->doc, MY_NODE, (xmlChar *)ns->str);
  if(ans == NULL)
  {
    Pike_error("Namespace %s does not exist.\n", ns->str);
  }

  attr = xmlNewNsProp(MY_NODE, ans, (xmlChar *)name->str, (xmlChar *)value->str);

  if(attr == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    push_object(this_object());
  }
}

/*! @decl object delete_attribute(string name, string|void ns)
 *!
 *! 
 */
PIKEFUN object delete_attribute(string name)
{
  check_node_created();
  xmlUnsetProp(MY_NODE, (xmlChar *)name->str);

  push_object(this_object());

}

PIKEFUN object delete_attribute(string name, string ns)
{
  xmlNsPtr ans;

  check_node_created();

  ans = xmlSearchNs(MY_NODE->doc, MY_NODE, (xmlChar *)ns->str);
  if(ans == NULL)
  {
    Pike_error("Namespace %s does not exist.\n", ns->str);
  }

  xmlUnsetNsProp(MY_NODE, ans, (xmlChar *)name->str);

  push_object(this_object());

}

PIKEFUN object set_attribute(string name, string value)
{
  struct object * o;
  xmlAttrPtr attr;
  xmlAttrPtr val;

  check_node_created();

  xmlUnsetProp(MY_NODE, (xmlChar *)name->str);

  attr = xmlNewProp(MY_NODE, (xmlChar *)name->str, (xmlChar *)value->str);

  if(attr == NULL)
  {
    pop_n_elems(2);
    push_int(0);
    return;
  }
  else
  {
    pop_n_elems(2);
    push_object(this_object());
  }
}

/*!  @decl Node new_char_ref(string name)
 *!     returns an unlinked character reference node.
 */
PIKEFUN object new_char_ref(string name)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  if(name->str[0] != '&' || name->str[0] != '#')
  {
    Pike_error("Invalid charater reference.\n");
  }

  node = xmlNewCharRef(MY_NODE->doc, name->str);
  
  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node new_comment(string content)
 *!     returns an unlinked character reference node.
 */
PIKEFUN object new_comment(string content)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlNewComment(content->str);
  
  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}



/*!  @decl Node new_child(string ns, string name, string content)
 *!     add a new child element, added to end of children for this node.
 */
PIKEFUN object new_child(string name, string content)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlNewChild(MY_NODE, NULL, name->str, content->str);
  
  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*! @decl Node add_ns(string href, string prefix)
 *!
 */
PIKEFUN object add_ns(string href, string prefix)
{
  xmlNsPtr ns;

  ns = xmlNewNs(MY_NODE, (xmlChar *) href->str, (xmlChar *) prefix->str);

  if(ns == NULL)
  {
    Pike_error("Unable to create new namespace.\n");
  }

  push_object(this_object());
}

/*!  @decl Node add_child(Node child)
 *!     add a node to end of children for this node.
 */
PIKEFUN object add_child(object child)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlAddChild(MY_NODE, OBJ2_NODE(child)->object_data->node);
  
  if(node == NULL || OBJ2_NODE(child)->object_data->node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node add_sibling(Node sibling)
 *!     add a node to end of siblings for this node.
 */
PIKEFUN object add_sibling(object sibling)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlAddSibling(MY_NODE, OBJ2_NODE(sibling)->object_data->node);
  
  if(node == NULL || OBJ2_NODE(sibling)->object_data->node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node add_next_sibling(Node sibling)
 *!     add a sibling node after this node.
 */
PIKEFUN object add_next_sibling(object sibling)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlAddNextSibling(MY_NODE, OBJ2_NODE(sibling)->object_data->node);
  
  if(node == NULL || OBJ2_NODE(sibling)->object_data->node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node add_prev_sibling(Node sibling)
 *!     add a sibling node after this node.
 */
PIKEFUN object add_prev_sibling(object sibling)
{
  struct object * o;
  xmlNodePtr node;

  check_node_created();

  node = xmlAddPrevSibling(MY_NODE, OBJ2_NODE(sibling)->object_data->node);
  
  if(node == NULL || OBJ2_NODE(sibling)->object_data->node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node get_last_child()
 *!     get the Node which is the last child of this Node.
 */
PIKEFUN object get_last_child()
{
  struct object * o;
  xmlNodePtr node;
  check_node_created();

  node = xmlGetLastChild(MY_NODE);

  if(node == NULL)
  {
    push_int(0);
    return;
  }
  else
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = node;
    NEW_NODE_REFS(o);
    push_object(o);
  }
}

/*!  @decl Node next()
 *!  get the next sibling of this Node.
 *!  @returns
 *!    the next node which is a sibling of this node.
 */
PIKEFUN object next()
{
  struct object * o;
  check_node_created();
  if(MY_NODE->next == NULL)
  {
    push_int(0);
    return;
  }
	
  else 
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = MY_NODE->next;
    NEW_NODE_REFS(o);
// printf("refs: %d\n", (* OBJ2_NODE(o)->object_data->refs));
    push_object(o);
  }
}

/*!  @decl Node prev()
 *!  get the previous sibling of this Node.
 *!  @returns
 *!    the previous node which is a sibling of this node.
 */
PIKEFUN object prev()
{
  struct object * o;
    check_node_created();
  if(MY_NODE->prev == NULL)
  {
    push_int(0);
    return;
  }

  else 
  {
    o = NEW_NODE();
    OBJ2_NODE(o)->object_data->node = MY_NODE->prev;
    NEW_NODE_REFS(o);

    push_object(o);
  }
}

/*! @decl int is_blank()
 *!
 *!  is this node empty?
 */
PIKEFUN int is_blank()
{
  check_node_created();

  RETURN xmlIsBlankNode(MY_NODE);
}

/*! @decl int is_text()
 *! 
 *!  is this a text node?
 */
PIKEFUN int is_text()
{
  check_node_created();

  RETURN xmlNodeIsText(MY_NODE);
}

/*!  @decl int get_node_type()
 *!
 *!  get the type of node.
 *!  
 *!  @returns
 *!   the integer node type. Node type constantes are 
 *!   defined in @[Constants].
PIKEFUN int get_node_type()
{
  check_node_created();

  push_int((int)(MY_NODE->type));
}

/*! @decl string get_node_name()
 *!  gets the name of this node, if it has one.
 */
PIKEFUN string get_node_name()
{
  check_node_created();
  if((char *)(MY_NODE->name) != NULL)
    push_text((char *)(MY_NODE->name));
  else push_int(0);
} 

/*! @decl string set_node_name(string name)
 *!  gets the name of this node, if it has one.
 */
PIKEFUN string set_node_name(string name)
{
  check_node_created();

  xmlNodeSetName(MY_NODE, (xmlChar *)name->str);

  push_object(this_object());
} 

/*! @decl string render_xml(int level, int format)
 *!
 *! renders the node and all children as xml. 
 *!
 *! @param level
 *!   the indentation level to use
 *!
 *! @param format
 *!    should the xml be formated for ease of human reading.
 *!    this setting only takes 	effect if 
 *!    Public.Parser.XML2.xmlKeepBlanksDefault(0) has been called.
 */
PIKEFUN string render_xml(int level, int format)
{
  int dumped;
  xmlBufferPtr buf;
  char * str;

  check_node_created();
  buf = xmlBufferCreate();
  dumped = xmlNodeDump(buf, MY_NODE->doc, MY_NODE, level, format);

  if(dumped>0)
  {
    str = (char *)xmlStrdup(buf->content);
    xmlBufferFree(buf);
    push_text(str);

  }
  
}

PIKEFUN mixed cast(string type)
{
  if(strcmp(type->str, "string") == 0)
  { 
    pop_stack();
    push_int(1);
    push_int(1);
    f_Node_render_xml(2);
    return;
  }
  else
  {
    pop_stack();
    Pike_error("Unsupported cast type.\n");
  }
}

int check_node_created()
{
  if(THIS->object_data->node != NULL)
    return 1;
  Pike_error("Node not initialized.\n");
}

INIT
{
  NODE_OBJECT_DATA * dta;

  dta = 
	(NODE_OBJECT_DATA*)malloc(sizeof(NODE_OBJECT_DATA));
    if (!dta)
        Pike_error("init_node: Out of memory!\n");

    dta->node = NULL;

    THIS->object_data = dta;
}

EXIT 
{
  if((* THIS->object_data->refs)==1)
  {
    // printf("*** Freeing Doc...\n");
    xmlFreeDoc(THIS->object_data->node->doc);
  }
  else
  {
   (*( THIS->object_data->refs)) --;
// printf("NODE EXIT, refs = %d\n", (*(THIS->object_data->refs)));
  }

   if(THIS->object_data)
  {
    free(THIS->object_data);
  }
}
}
/*! @endclass
 */

/*
  
    start of Public.Parser.XML2 module functions

*/

/*! @decl array(Node) select_xpath_nodes(string xpath, object node)
 *!
 *! selects nodes based on an XPath query and returns the result.
 */
PIKEFUN array select_xpath_nodes(string xpath, object node)
{
  xmlXPathContextPtr xpathCtx;
  xmlXPathObjectPtr xpathObj;
  xmlNodeSetPtr set;
  xmlNodePtr xn;
  struct object * o;
  int num_nodes = 0;

//  check_node_created();
  if(OBJ2_NODE(node)->object_data->node == NULL)
  { 
    pop_n_elems(2);
    Pike_error("Node not initialized.\n");
  }

  xpathCtx = xmlXPathNewContext(OBJ2_NODE(node)->object_data->node->doc);
  if(xpathCtx == NULL)
  {
    pop_n_elems(2);
    Pike_error("Unable to create new XPath context.\n");
  }
  xpathObj = xmlXPathEvalExpression((xmlChar *)xpath->str, xpathCtx);
  if(xpathObj == NULL) {  
    pop_n_elems(2);
    xmlXPathFreeContext(xpathCtx);
    Pike_error("Unable to evaluate the XPath expression.\n");
  }

  /* now we should generate an array from the node set. */
  set = xpathObj->nodesetval;


  if(set == NULL)
  {
    pop_n_elems(2);
    push_int(0);
    xmlXPathFreeContext(xpathCtx);
    xmlXPathFreeObject(xpathObj);
    return;
  }  

  pop_n_elems(2);

  if(set->nodeNr > 0)
  {
  xn = set->nodeTab[0];
    if(xn != NULL && set->nodeNr > 0) do
    {
      struct Node_struct * ns;
      NODE_OBJECT_DATA * od;

      apply(Pike_fp->current_object, "Node", 0);
      ns = OBJ2_NODE((Pike_sp[0-1].u.object));
      od = (NODE_OBJECT_DATA *)(ns->object_data);

      od->node=xn;
      od->refs = OBJ2_NODE(node)->object_data->refs;
    
      (* od->refs)++;

      num_nodes++;
      xn = set->nodeTab[num_nodes];
    } 
    while (((num_nodes +1) <= set->nodeNr) && xn != NULL);


    if(num_nodes>0) {
      f_aggregate(num_nodes);
    }
  }
  else push_int(0);

  xmlXPathFreeContext(xpathCtx);
  xmlXPathFreeObject(xpathObj);

  return;
}

/*! @decl int substituteEntitiesDefault(int def)
 */
PIKEFUN void substituteEntitiesDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  xmlSubstituteEntitiesDefault(def);

  push_int(def);
}

/* @decl int keepBlanksDefault(int def)
 */
PIKEFUN int keepBlanksDefault(int def)
{
  def = def ? 1 : 0;

  pop_n_elems(args);

  push_int(xmlKeepBlanksDefault(def));
}

/*!  @decl string utf8_to_html(string str)
 *!
 */
PIKEFUN string utf8_to_html(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8ToHtml(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to html!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}


/*!  @decl string utf8_to_isolat1(string str)
 *!
 */
PIKEFUN string utf8_to_isolat1(string str)
{
  char *html = NULL;
  int outlen, inlen;

  outlen = str->len << 1;
  html = (char*)malloc(outlen + 1);
  if (!html)
    Pike_error("Out of memory");

  inlen = str->len;
  if ( UTF8Toisolat1(html, &outlen, str->str, &inlen) < 0 ) {
    free(html);
    Pike_error("Cannot convert to isolat1!");
  }
  html[outlen] = '\0';
  pop_n_elems(args);
  push_text(html);
  free(html);
}

/*! @decl int utf8_check(string str)
 *!
 */
PIKEFUN int utf8_check(string str)
{
  int result;

  result = xmlCheckUTF8(str->str);
  pop_n_elems(args);
  push_int(result);
}

/*! @decl string render_xml(Node n)
 *!   Renders a node tree as an XML string. The entire document tree will 
 *!  be rendered. To render a portion of a tree, use @[Node.render_xml].
 *!
 *!   @param n
 *!     a Node object for a given XML document.
 *!
 */
PIKEFUN string render_xml(object n)
{
  int dumped;
  xmlChar * buf;
  char * str;
  int bufsize;

//  check_node_created();
  if(OBJ2_NODE(n)->object_data->node == NULL)
  { 
    Pike_error("Node not initialized.\n");
  }

  xmlDocDumpFormatMemory(OBJ2_NODE(n)->object_data->node->doc, &buf, &bufsize, 1);

  if(buf!=NULL)
  {
    str = (char *)xmlStrdup(buf);
    xmlFree(buf);
    push_text(str);
  }  
  else
  {
    push_int(0);
  }
}

/*! @decl Node parse_xml(string xml)
 *!   Parse an string containing XML.
 *!
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object parse_xml(string xml)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlReadMemory(xml->str, xml->len, "noname.xml", NULL, 0);
  if(doc == NULL)
  {
    Pike_error("Unable to parse XML.\n");
  }  

  node = xmlDocGetRootElement(doc);
  if(node == NULL)
  {
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
// printf("refs: %d\n", *(od->refs));
  od->node = node;
}



/*! @decl Node new_xml(string version)
 *!   Create a new XML document with a root node.
 *!
 *!  @param version
 *!     the version of XML to create
 *!  @param root_name
 *!      the name of the root node
 *!  @returns
 *!    a @[Node] object containing the root of the tree.
 */
PIKEFUN object new_xml(string version, string root_name)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  struct Node_struct * ns;
  NODE_OBJECT_DATA * od;

  doc = xmlNewDoc(version->str);

  if(doc == NULL)
  {
    Pike_error("Unable to create new XML document.\n");
  }  
  node = xmlNewNode(NULL, (xmlChar *)root_name->str);
  xmlDocSetRootElement(doc, node);
  if(node == NULL)
  {
    xmlFreeDoc(doc);
    Pike_error("Unable to find Root Node.\n");
  }

  // ok, we have a parsed file. now let's turn it into a real live pike object.

  pop_stack();

  apply(Pike_fp->current_object, "Node", 0);
  
  ns = OBJ2_NODE((Pike_sp[0-1].u.object));
  od = (NODE_OBJECT_DATA *)(ns->object_data);

  od->refs = malloc(sizeof(INT32));
  (* od->refs)=1;
// printf("refs: %d\n", *(od->refs));
  od->node = node;
}

EXTRA
{
  add_string_constant("__version", "1.6", 0);
  add_string_constant("__author", "Bill Welliver <bill@welliver.org>", 0);

}

INIT
{

  LIBXML_TEST_VERSION

}

EXIT 
{
  xmlCleanupParser();
}

/*! @class Constants
 */

PIKECLASS Constants
{
EXTRA
{
  xmlElementType type;

  type=XML_ELEMENT_NODE;
  add_integer_constant("ELEMENT_NODE", type, 0);
  type=XML_ATTRIBUTE_NODE;
  add_integer_constant("ATTRIBUTE_NODE", type, 0);
  type=XML_TEXT_NODE;
  add_integer_constant("TEXT_NODE", type, 0);
  type=XML_CDATA_SECTION_NODE;
  add_integer_constant("CDATA_SECTION_NODE", type, 0);
  type=XML_ENTITY_REF_NODE;
  add_integer_constant("ENTITY_REF_NODE", type, 0);
  type=XML_ENTITY_NODE;
  add_integer_constant("ENTITY_NODE", type, 0);
  type=XML_PI_NODE;
  add_integer_constant("PI_NODE", type, 0);
  type=XML_COMMENT_NODE;
  add_integer_constant("COMMENT_NODE", type, 0);
  type=XML_ELEMENT_DECL;
  add_integer_constant("ELEMENT_DECL", type, 0);

/* SAX callback constants */
add_integer_constant("SAX_CB_INTERNALSUBSET", CB_INTERNALSUBSET, 0);
add_integer_constant("SAX_CB_ISSTANDALONE", CB_ISSTANDALONE, 0);
add_integer_constant("SAX_CB_HASINTERNALSUBSET", CB_HASINTERNALSUBSET, 0);
add_integer_constant("SAX_CB_HASEXTERNALSUBSET", CB_HASEXTERNALSUBSET, 0);
add_integer_constant("SAX_CB_RESOLVEENTITY", CB_RESOLVEENTITY, 0);
add_integer_constant("SAX_CB_GETENTITY", CB_GETENTITY, 0);
add_integer_constant("SAX_CB_ENTITYDECL", CB_ENTITYDECL, 0);
add_integer_constant("SAX_CB_NOTATIONDECL", CB_NOTATIONDECL, 0);
add_integer_constant("SAX_CB_ATTRIBUTEDECL", CB_ATTRIBUTEDECL, 0);
add_integer_constant("SAX_CB_ELEMENTDECL", CB_ELEMENTDECL, 0);
add_integer_constant("SAX_CB_UNPARSEDENTITYDECL", CB_UNPARSEDENTITYDECL, 
0);
add_integer_constant("SAX_CB_SETDOCUMENTLOCATOR", CB_SETDOCUMENTLOCATOR, 
0);
add_integer_constant("SAX_CB_STARTDOCUMENT", CB_STARTDOCUMENT, 0);
add_integer_constant("SAX_CB_ENDDOCUMENT", CB_ENDDOCUMENT, 0);
add_integer_constant("SAX_CB_STARTELEMENT", CB_STARTELEMENT, 0);
add_integer_constant("SAX_CB_ENDELEMENT", CB_ENDELEMENT, 0);
add_integer_constant("SAX_CB_REFERENCE", CB_REFERENCE, 0);
add_integer_constant("SAX_CB_CHARACTERS", CB_CHARACTERS, 0);
add_integer_constant("SAX_CB_IGNORABLEWHITESPACE", CB_IGNORABLEWHITESPACE, 
0);
add_integer_constant("SAX_CB_PROCESSINGINSTRUCTION", 
CB_PROCESSINGINSTRUCTION, 0);
add_integer_constant("SAX_CB_COMMENT", CB_COMMENT, 0);
add_integer_constant("SAX_CB_WARNING", CB_WARNING, 0);
add_integer_constant("SAX_CB_ERROR", CB_ERROR, 0);
add_integer_constant("SAX_CB_FATALERROR", CB_FATALERROR, 0);
add_integer_constant("SAX_CB_GETPARAMETERENTITY", CB_GETPARAMETERENTITY, 
0);
add_integer_constant("SAX_CB_CDATABLOCK", CB_CDATABLOCK, 0);
add_integer_constant("SAX_CB_EXTERNALSUBSET", CB_EXTERNALSUBSET, 0);

/*  we don't know how SAX2 works yet...  */
/*
add_integer_constant("SAX_CB_STARTELEMENTNS", CB_STARTELEMENTNS, 0);
add_integer_constant("SAX_CB_ENDELEMENTNS", CB_ENDELEMENTNS, 0);
*/
add_integer_constant("SAX_CB_SERROR", CB_SERROR, 0);
    /* some constants */  
  add_integer_constant("INTERNAL_GENERAL_ENTITY", XML_INTERNAL_GENERAL_ENTITY, 0);
  add_integer_constant("EXTERNAL_GENERAL_PARSED_ENTITY", XML_EXTERNAL_GENERAL_PARSED_ENTITY, 0);
  add_integer_constant("EXTERNAL_GENERAL_UNPARSED_ENTITY", XML_EXTERNAL_GENERAL_UNPARSED_ENTITY, 0);
  add_integer_constant("INTERNAL_PARAMETER_ENTITY", XML_INTERNAL_PARAMETER_ENTITY, 0);
  add_integer_constant("EXTERNAL_PARAMETER_ENTITY", XML_EXTERNAL_PARAMETER_ENTITY, 0);
  add_integer_constant("INTERNAL_PREDEFINED_ENTITY", XML_INTERNAL_PREDEFINED_ENTITY, 0);

  add_integer_constant("ATTRIBUTE_CDATA", XML_ATTRIBUTE_CDATA, 0);
  add_integer_constant("ATTRIBUTE_ID", XML_ATTRIBUTE_ID, 0);
  add_integer_constant("ATTRIBUTE_IDREF", XML_ATTRIBUTE_IDREF, 0);
  add_integer_constant("ATTRIBUTE_IDREFS", XML_ATTRIBUTE_IDREFS, 0);
  add_integer_constant("ATTRIBUTE_ENTITY", XML_ATTRIBUTE_ENTITY, 0);
  add_integer_constant("ATTRIBUTE_ENTITIES", XML_ATTRIBUTE_ENTITIES, 0);
  add_integer_constant("ATTRIBUTE_NMTOKEN", XML_ATTRIBUTE_NMTOKEN, 0);
  add_integer_constant("ATTRIBUTE_NMTOKENS", XML_ATTRIBUTE_NMTOKENS, 0);
  add_integer_constant("ATTRIBUTE_ENUMERATION", XML_ATTRIBUTE_ENUMERATION, 0);
  add_integer_constant("ATTRIBUTE_NOTATION", XML_ATTRIBUTE_NOTATION, 0);

  add_integer_constant("ATTRIBUTE_NONE", XML_ATTRIBUTE_NONE, 0);
  add_integer_constant("ATTRIBUTE_REQUIRED", XML_ATTRIBUTE_REQUIRED, 0);
  add_integer_constant("ATTRIBUTE_IMPLIED", XML_ATTRIBUTE_IMPLIED, 0);
  add_integer_constant("ATTRIBUTE_FIXED", XML_ATTRIBUTE_FIXED, 0);

  add_integer_constant("ELEMENT_CONTENT_PCDATA", XML_ELEMENT_CONTENT_PCDATA, 0);
  add_integer_constant("ELEMENT_CONTENT_ELEMENT", XML_ELEMENT_CONTENT_ELEMENT, 0);
  add_integer_constant("ELEMENT_CONTENT_SEQ", XML_ELEMENT_CONTENT_SEQ, 0);
  add_integer_constant("ELEMENT_CONTENT_OR", XML_ELEMENT_CONTENT_OR, 0);

  add_integer_constant("ELEMENT_CONTENT_ONCE", XML_ELEMENT_CONTENT_ONCE, 0);
  add_integer_constant("ELEMENT_CONTENT_OPT", XML_ELEMENT_CONTENT_OPT, 0);
  add_integer_constant("ELEMENT_CONTENT_MULT", XML_ELEMENT_CONTENT_MULT, 0);
  add_integer_constant("ELEMENT_CONTENT_PLUS", XML_ELEMENT_CONTENT_PLUS, 0);

  add_integer_constant("ELEMENT_TYPE_UNDEFINED", XML_ELEMENT_TYPE_UNDEFINED, 0);
  add_integer_constant("ELEMENT_TYPE_EMPTY", XML_ELEMENT_TYPE_EMPTY, 0);
  add_integer_constant("ELEMENT_TYPE_ANY", XML_ELEMENT_TYPE_ANY, 0);
  add_integer_constant("ELEMENT_TYPE_MIXED", XML_ELEMENT_TYPE_MIXED, 0);
  add_integer_constant("ELEMENT_TYPE_ELEMENT", XML_ELEMENT_TYPE_ELEMENT, 0);

  /* error codes */
  add_integer_constant("ERR_OK", XML_ERR_OK, 0);
  add_integer_constant("ERR_INTERNAL_ERROR", XML_ERR_INTERNAL_ERROR, 0);
  add_integer_constant("ERR_NO_MEMORY", XML_ERR_NO_MEMORY, 0);
  add_integer_constant("ERR_DOCUMENT_START", XML_ERR_DOCUMENT_START, 0);
  add_integer_constant("ERR_DOCUMENT_EMPTY", XML_ERR_DOCUMENT_EMPTY, 0);
  add_integer_constant("ERR_DOCUMENT_END", XML_ERR_DOCUMENT_END, 0);
  add_integer_constant("ERR_INVALID_HEX_CHARREF", XML_ERR_INVALID_HEX_CHARREF, 0);
  add_integer_constant("ERR_INVALID_DEC_CHARREF", XML_ERR_INVALID_DEC_CHARREF, 0);
  add_integer_constant("ERR_INVALID_CHARREF", XML_ERR_INVALID_CHARREF, 0);
  add_integer_constant("ERR_INVALID_CHAR", XML_ERR_INVALID_CHAR, 0);
  add_integer_constant("ERR_CHARREF_AT_EOF", XML_ERR_CHARREF_AT_EOF, 0);
  add_integer_constant("ERR_CHARREF_IN_PROLOG", XML_ERR_CHARREF_IN_PROLOG, 0);
  add_integer_constant("ERR_CHARREF_IN_EPILOG", XML_ERR_CHARREF_IN_EPILOG, 0);
  add_integer_constant("ERR_CHARREF_IN_DTD", XML_ERR_CHARREF_IN_DTD, 0);
  add_integer_constant("ERR_ENTITYREF_AT_EOF", XML_ERR_ENTITYREF_AT_EOF, 0);
  add_integer_constant("ERR_ENTITYREF_IN_PROLOG", XML_ERR_ENTITYREF_IN_PROLOG, 0);
  add_integer_constant("ERR_ENTITYREF_IN_EPILOG", XML_ERR_ENTITYREF_IN_EPILOG, 0);
  add_integer_constant("ERR_ENTITYREF_IN_DTD", XML_ERR_ENTITYREF_IN_DTD, 0);
  add_integer_constant("ERR_PEREF_AT_EOF", XML_ERR_PEREF_AT_EOF, 0);
  add_integer_constant("ERR_PEREF_IN_PROLOG", XML_ERR_PEREF_IN_PROLOG, 0);
  add_integer_constant("ERR_PEREF_IN_EPILOG", XML_ERR_PEREF_IN_EPILOG, 0);
  add_integer_constant("ERR_PEREF_IN_INT_SUBSET", XML_ERR_PEREF_IN_INT_SUBSET, 0);
  add_integer_constant("ERR_ENTITYREF_NO_NAME", XML_ERR_ENTITYREF_NO_NAME, 0);
  add_integer_constant("ERR_ENTITYREF_SEMICOL_MISSING", XML_ERR_ENTITYREF_SEMICOL_MISSING, 0);
  add_integer_constant("ERR_PEREF_NO_NAME", XML_ERR_PEREF_NO_NAME, 0);
  add_integer_constant("ERR_PEREF_SEMICOL_MISSING", XML_ERR_PEREF_SEMICOL_MISSING, 0);
  add_integer_constant("ERR_UNDECLARED_ENTITY", XML_ERR_UNDECLARED_ENTITY, 0);
  add_integer_constant("WAR_UNDECLARED_ENTITY", XML_WAR_UNDECLARED_ENTITY, 0);
  add_integer_constant("ERR_UNPARSED_ENTITY", XML_ERR_UNPARSED_ENTITY, 0);
  add_integer_constant("ERR_ENTITY_IS_EXTERNAL", XML_ERR_ENTITY_IS_EXTERNAL, 0);
  add_integer_constant("ERR_ENTITY_IS_PARAMETER", XML_ERR_ENTITY_IS_PARAMETER, 0);
  add_integer_constant("ERR_UNKNOWN_ENCODING", XML_ERR_UNKNOWN_ENCODING, 0);
  add_integer_constant("ERR_UNSUPPORTED_ENCODING", XML_ERR_UNSUPPORTED_ENCODING, 0);
  add_integer_constant("ERR_STRING_NOT_STARTED", XML_ERR_STRING_NOT_STARTED, 0);
  add_integer_constant("ERR_STRING_NOT_CLOSED", XML_ERR_STRING_NOT_CLOSED, 0);
  add_integer_constant("ERR_NS_DECL_ERROR", XML_ERR_NS_DECL_ERROR, 0);
  add_integer_constant("ERR_ENTITY_NOT_STARTED", XML_ERR_ENTITY_NOT_STARTED, 0);
  add_integer_constant("ERR_ENTITY_NOT_FINISHED", XML_ERR_ENTITY_NOT_FINISHED, 0);
  add_integer_constant("ERR_LT_IN_ATTRIBUTE", XML_ERR_LT_IN_ATTRIBUTE, 0);
  add_integer_constant("ERR_ATTRIBUTE_NOT_STARTED", XML_ERR_ATTRIBUTE_NOT_STARTED, 0);
  add_integer_constant("ERR_ATTRIBUTE_NOT_FINISHED", XML_ERR_ATTRIBUTE_NOT_FINISHED, 0);
  add_integer_constant("ERR_ATTRIBUTE_WITHOUT_VALUE", XML_ERR_ATTRIBUTE_WITHOUT_VALUE, 0);
  add_integer_constant("ERR_ATTRIBUTE_REDEFINED", XML_ERR_ATTRIBUTE_REDEFINED, 0);
  add_integer_constant("ERR_LITERAL_NOT_STARTED", XML_ERR_LITERAL_NOT_STARTED, 0);
  add_integer_constant("ERR_LITERAL_NOT_FINISHED", XML_ERR_LITERAL_NOT_FINISHED, 0);
  add_integer_constant("ERR_COMMENT_NOT_FINISHED", XML_ERR_COMMENT_NOT_FINISHED, 0);
  add_integer_constant("ERR_PI_NOT_STARTED", XML_ERR_PI_NOT_STARTED, 0);
  add_integer_constant("ERR_PI_NOT_FINISHED", XML_ERR_PI_NOT_FINISHED, 0);
  add_integer_constant("ERR_NOTATION_NOT_STARTED", XML_ERR_NOTATION_NOT_STARTED, 0);
  add_integer_constant("ERR_NOTATION_NOT_FINISHED", XML_ERR_NOTATION_NOT_FINISHED, 0);
  add_integer_constant("ERR_ATTLIST_NOT_STARTED", XML_ERR_ATTLIST_NOT_STARTED, 0);
  add_integer_constant("ERR_ATTLIST_NOT_FINISHED", XML_ERR_ATTLIST_NOT_FINISHED, 0);
  add_integer_constant("ERR_MIXED_NOT_STARTED", XML_ERR_MIXED_NOT_STARTED, 0);
  add_integer_constant("ERR_MIXED_NOT_FINISHED", XML_ERR_MIXED_NOT_FINISHED, 0);
  add_integer_constant("ERR_ELEMCONTENT_NOT_STARTED", XML_ERR_ELEMCONTENT_NOT_STARTED, 0);
  add_integer_constant("ERR_ELEMCONTENT_NOT_FINISHED", XML_ERR_ELEMCONTENT_NOT_FINISHED, 0);
  add_integer_constant("ERR_XMLDECL_NOT_STARTED", XML_ERR_XMLDECL_NOT_STARTED, 0);
  add_integer_constant("ERR_XMLDECL_NOT_FINISHED", XML_ERR_XMLDECL_NOT_FINISHED, 0);
  add_integer_constant("ERR_CONDSEC_NOT_STARTED", XML_ERR_CONDSEC_NOT_STARTED, 0);
  add_integer_constant("ERR_CONDSEC_NOT_FINISHED", XML_ERR_CONDSEC_NOT_FINISHED, 0);
  add_integer_constant("ERR_EXT_SUBSET_NOT_FINISHED", XML_ERR_EXT_SUBSET_NOT_FINISHED, 0);
  add_integer_constant("ERR_DOCTYPE_NOT_FINISHED", XML_ERR_DOCTYPE_NOT_FINISHED, 0);
  add_integer_constant("ERR_MISPLACED_CDATA_END", XML_ERR_MISPLACED_CDATA_END, 0);
  add_integer_constant("ERR_CDATA_NOT_FINISHED", XML_ERR_CDATA_NOT_FINISHED, 0);
  add_integer_constant("ERR_RESERVED_XML_NAME", XML_ERR_RESERVED_XML_NAME, 0);
  add_integer_constant("ERR_SPACE_REQUIRED", XML_ERR_SPACE_REQUIRED, 0);
  add_integer_constant("ERR_SEPARATOR_REQUIRED", XML_ERR_SEPARATOR_REQUIRED, 0);
  add_integer_constant("ERR_NMTOKEN_REQUIRED", XML_ERR_NMTOKEN_REQUIRED, 0);
  add_integer_constant("ERR_NAME_REQUIRED", XML_ERR_NAME_REQUIRED, 0);
  add_integer_constant("ERR_PCDATA_REQUIRED", XML_ERR_PCDATA_REQUIRED, 0);
  add_integer_constant("ERR_URI_REQUIRED", XML_ERR_URI_REQUIRED, 0);
  add_integer_constant("ERR_PUBID_REQUIRED", XML_ERR_PUBID_REQUIRED, 0);
  add_integer_constant("ERR_LT_REQUIRED", XML_ERR_LT_REQUIRED, 0);
  add_integer_constant("ERR_GT_REQUIRED", XML_ERR_GT_REQUIRED, 0);
  add_integer_constant("ERR_LTSLASH_REQUIRED", XML_ERR_LTSLASH_REQUIRED, 0);
  add_integer_constant("ERR_EQUAL_REQUIRED", XML_ERR_EQUAL_REQUIRED, 0);
  add_integer_constant("ERR_TAG_NAME_MISMATCH", XML_ERR_TAG_NAME_MISMATCH, 0);
  add_integer_constant("ERR_TAG_NOT_FINISHED", XML_ERR_TAG_NOT_FINISHED, 0);
  add_integer_constant("ERR_STANDALONE_VALUE", XML_ERR_STANDALONE_VALUE, 0);
  add_integer_constant("ERR_ENCODING_NAME", XML_ERR_ENCODING_NAME, 0);
  add_integer_constant("ERR_HYPHEN_IN_COMMENT", XML_ERR_HYPHEN_IN_COMMENT, 0);
  add_integer_constant("ERR_INVALID_ENCODING", XML_ERR_INVALID_ENCODING, 0);
  add_integer_constant("ERR_EXT_ENTITY_STANDALONE", XML_ERR_EXT_ENTITY_STANDALONE, 0);
  add_integer_constant("ERR_CONDSEC_INVALID", XML_ERR_CONDSEC_INVALID, 0);
  add_integer_constant("ERR_VALUE_REQUIRED", XML_ERR_VALUE_REQUIRED, 0);
  add_integer_constant("ERR_NOT_WELL_BALANCED", XML_ERR_NOT_WELL_BALANCED, 0);
  add_integer_constant("ERR_EXTRA_CONTENT", XML_ERR_EXTRA_CONTENT, 0);
  add_integer_constant("ERR_ENTITY_CHAR_ERROR", XML_ERR_ENTITY_CHAR_ERROR, 0);
  add_integer_constant("ERR_ENTITY_PE_INTERNAL", XML_ERR_ENTITY_PE_INTERNAL, 0);
  add_integer_constant("ERR_ENTITY_LOOP", XML_ERR_ENTITY_LOOP, 0);
  add_integer_constant("ERR_ENTITY_BOUNDARY", XML_ERR_ENTITY_BOUNDARY, 0);
  add_integer_constant("ERR_INVALID_URI", XML_ERR_INVALID_URI, 0);
  add_integer_constant("ERR_URI_FRAGMENT", XML_ERR_URI_FRAGMENT, 0);
  add_integer_constant("WAR_CATALOG_PI", XML_WAR_CATALOG_PI, 0);
  add_integer_constant("ERR_NO_DTD", XML_ERR_NO_DTD, 0);
  add_integer_constant("ERR_CONDSEC_INVALID_KEYWORD", XML_ERR_CONDSEC_INVALID_KEYWORD, 0);
  add_integer_constant("ERR_VERSION_MISSING", XML_ERR_VERSION_MISSING, 0);
  add_integer_constant("WAR_UNKNOWN_VERSION", XML_WAR_UNKNOWN_VERSION, 0);
  add_integer_constant("WAR_LANG_VALUE", XML_WAR_LANG_VALUE, 0);
  add_integer_constant("WAR_NS_URI", XML_WAR_NS_URI, 0);
  add_integer_constant("WAR_NS_URI_RELATIVE", XML_WAR_NS_URI_RELATIVE, 0);
  add_integer_constant("ERR_MISSING_ENCODING", XML_ERR_MISSING_ENCODING, 0);
  add_integer_constant("NS_ERR_XML_NAMESPACE", XML_NS_ERR_XML_NAMESPACE, 0);
  add_integer_constant("NS_ERR_UNDEFINED_NAMESPACE", XML_NS_ERR_UNDEFINED_NAMESPACE, 0);
  add_integer_constant("NS_ERR_QNAME", XML_NS_ERR_QNAME, 0);
  add_integer_constant("NS_ERR_ATTRIBUTE_REDEFINED", XML_NS_ERR_ATTRIBUTE_REDEFINED, 0);
  add_integer_constant("DTD_ATTRIBUTE_DEFAULT", XML_DTD_ATTRIBUTE_DEFAULT, 0);
  add_integer_constant("DTD_ATTRIBUTE_REDEFINED", XML_DTD_ATTRIBUTE_REDEFINED, 0);
  add_integer_constant("DTD_ATTRIBUTE_VALUE", XML_DTD_ATTRIBUTE_VALUE, 0);
  add_integer_constant("DTD_CONTENT_ERROR", XML_DTD_CONTENT_ERROR, 0);
  add_integer_constant("DTD_CONTENT_MODEL", XML_DTD_CONTENT_MODEL, 0);
  add_integer_constant("DTD_CONTENT_NOT_DETERMINIST", XML_DTD_CONTENT_NOT_DETERMINIST, 0);
  add_integer_constant("DTD_DIFFERENT_PREFIX", XML_DTD_DIFFERENT_PREFIX, 0);
  add_integer_constant("DTD_ELEM_DEFAULT_NAMESPACE", XML_DTD_ELEM_DEFAULT_NAMESPACE, 0);
  add_integer_constant("DTD_ELEM_NAMESPACE", XML_DTD_ELEM_NAMESPACE, 0);
  add_integer_constant("DTD_ELEM_REDEFINED", XML_DTD_ELEM_REDEFINED, 0);
  add_integer_constant("DTD_EMPTY_NOTATION", XML_DTD_EMPTY_NOTATION, 0);
  add_integer_constant("DTD_ENTITY_TYPE", XML_DTD_ENTITY_TYPE, 0);
  add_integer_constant("DTD_ID_FIXED", XML_DTD_ID_FIXED, 0);
  add_integer_constant("DTD_ID_REDEFINED", XML_DTD_ID_REDEFINED, 0);
  add_integer_constant("DTD_ID_SUBSET", XML_DTD_ID_SUBSET, 0);
  add_integer_constant("DTD_INVALID_CHILD", XML_DTD_INVALID_CHILD, 0);
  add_integer_constant("DTD_INVALID_DEFAULT", XML_DTD_INVALID_DEFAULT, 0);
  add_integer_constant("DTD_LOAD_ERROR", XML_DTD_LOAD_ERROR, 0);
  add_integer_constant("DTD_MISSING_ATTRIBUTE", XML_DTD_MISSING_ATTRIBUTE, 0);
  add_integer_constant("DTD_MIXED_CORRUPT", XML_DTD_MIXED_CORRUPT, 0);
  add_integer_constant("DTD_MULTIPLE_ID", XML_DTD_MULTIPLE_ID, 0);
  add_integer_constant("DTD_NO_DOC", XML_DTD_NO_DOC, 0);
  add_integer_constant("DTD_NO_DTD", XML_DTD_NO_DTD, 0);
  add_integer_constant("DTD_NO_ELEM_NAME", XML_DTD_NO_ELEM_NAME, 0);
  add_integer_constant("DTD_NO_PREFIX", XML_DTD_NO_PREFIX, 0);
  add_integer_constant("DTD_NO_ROOT", XML_DTD_NO_ROOT, 0);
  add_integer_constant("DTD_NOTATION_REDEFINED", XML_DTD_NOTATION_REDEFINED, 0);
  add_integer_constant("DTD_NOTATION_VALUE", XML_DTD_NOTATION_VALUE, 0);
  add_integer_constant("DTD_NOT_EMPTY", XML_DTD_NOT_EMPTY, 0);
  add_integer_constant("DTD_NOT_PCDATA", XML_DTD_NOT_PCDATA, 0);
  add_integer_constant("DTD_NOT_STANDALONE", XML_DTD_NOT_STANDALONE, 0);
  add_integer_constant("DTD_ROOT_NAME", XML_DTD_ROOT_NAME, 0);
  add_integer_constant("DTD_STANDALONE_WHITE_SPACE", XML_DTD_STANDALONE_WHITE_SPACE, 0);
  add_integer_constant("DTD_UNKNOWN_ATTRIBUTE", XML_DTD_UNKNOWN_ATTRIBUTE, 0);
  add_integer_constant("DTD_UNKNOWN_ELEM", XML_DTD_UNKNOWN_ELEM, 0);
  add_integer_constant("DTD_UNKNOWN_ENTITY", XML_DTD_UNKNOWN_ENTITY, 0);
  add_integer_constant("DTD_UNKNOWN_ID", XML_DTD_UNKNOWN_ID, 0);
  add_integer_constant("DTD_UNKNOWN_NOTATION", XML_DTD_UNKNOWN_NOTATION, 0);
  add_integer_constant("DTD_STANDALONE_DEFAULTED", XML_DTD_STANDALONE_DEFAULTED, 0);
  add_integer_constant("DTD_XMLID_VALUE", XML_DTD_XMLID_VALUE, 0);
  add_integer_constant("DTD_XMLID_TYPE", XML_DTD_XMLID_TYPE, 0);
  add_integer_constant("HTML_STRUCURE_ERROR", XML_HTML_STRUCURE_ERROR, 0);
  add_integer_constant("HTML_UNKNOWN_TAG", XML_HTML_UNKNOWN_TAG, 0);
  add_integer_constant("RNGP_ANYNAME_ATTR_ANCESTOR", XML_RNGP_ANYNAME_ATTR_ANCESTOR, 0);
  add_integer_constant("RNGP_ATTR_CONFLICT", XML_RNGP_ATTR_CONFLICT, 0);
  add_integer_constant("RNGP_ATTRIBUTE_CHILDREN", XML_RNGP_ATTRIBUTE_CHILDREN, 0);
  add_integer_constant("RNGP_ATTRIBUTE_CONTENT", XML_RNGP_ATTRIBUTE_CONTENT, 0);
  add_integer_constant("RNGP_ATTRIBUTE_EMPTY", XML_RNGP_ATTRIBUTE_EMPTY, 0);
  add_integer_constant("RNGP_ATTRIBUTE_NOOP", XML_RNGP_ATTRIBUTE_NOOP, 0);
  add_integer_constant("RNGP_CHOICE_CONTENT", XML_RNGP_CHOICE_CONTENT, 0);
  add_integer_constant("RNGP_CHOICE_EMPTY", XML_RNGP_CHOICE_EMPTY, 0);
  add_integer_constant("RNGP_CREATE_FAILURE", XML_RNGP_CREATE_FAILURE, 0);
  add_integer_constant("RNGP_DATA_CONTENT", XML_RNGP_DATA_CONTENT, 0);
  add_integer_constant("RNGP_DEF_CHOICE_AND_INTERLEAVE", XML_RNGP_DEF_CHOICE_AND_INTERLEAVE, 0);
  add_integer_constant("RNGP_DEFINE_CREATE_FAILED", XML_RNGP_DEFINE_CREATE_FAILED, 0);
  add_integer_constant("RNGP_DEFINE_EMPTY", XML_RNGP_DEFINE_EMPTY, 0);
  add_integer_constant("RNGP_DEFINE_MISSING", XML_RNGP_DEFINE_MISSING, 0);  
  add_integer_constant("RNGP_DEFINE_NAME_MISSING", XML_RNGP_DEFINE_NAME_MISSING, 0);
  add_integer_constant("RNGP_ELEM_CONTENT_EMPTY", XML_RNGP_ELEM_CONTENT_EMPTY, 0);
  add_integer_constant("RNGP_ELEM_CONTENT_ERROR", XML_RNGP_ELEM_CONTENT_ERROR, 0);
  add_integer_constant("RNGP_ELEMENT_EMPTY", XML_RNGP_ELEMENT_EMPTY, 0);
  add_integer_constant("RNGP_ELEMENT_CONTENT", XML_RNGP_ELEMENT_CONTENT, 0);
  add_integer_constant("RNGP_ELEMENT_NAME", XML_RNGP_ELEMENT_NAME, 0);
  add_integer_constant("RNGP_ELEMENT_NO_CONTENT", XML_RNGP_ELEMENT_NO_CONTENT, 0);
  add_integer_constant("RNGP_ELEM_TEXT_CONFLICT", XML_RNGP_ELEM_TEXT_CONFLICT, 0);
  add_integer_constant("RNGP_EMPTY", XML_RNGP_EMPTY, 0);
  add_integer_constant("RNGP_EMPTY_CONSTRUCT", XML_RNGP_EMPTY_CONSTRUCT, 0);
  add_integer_constant("RNGP_EMPTY_CONTENT", XML_RNGP_EMPTY_CONTENT, 0);
  add_integer_constant("RNGP_EMPTY_NOT_EMPTY", XML_RNGP_EMPTY_NOT_EMPTY, 0);
  add_integer_constant("RNGP_ERROR_TYPE_LIB", XML_RNGP_ERROR_TYPE_LIB, 0);
  add_integer_constant("RNGP_EXCEPT_EMPTY", XML_RNGP_EXCEPT_EMPTY, 0);
  add_integer_constant("RNGP_EXCEPT_MISSING", XML_RNGP_EXCEPT_MISSING, 0);
  add_integer_constant("RNGP_EXCEPT_MULTIPLE", XML_RNGP_EXCEPT_MULTIPLE, 0);
  add_integer_constant("RNGP_EXCEPT_NO_CONTENT", XML_RNGP_EXCEPT_NO_CONTENT, 0);
  add_integer_constant("RNGP_EXTERNALREF_EMTPY", XML_RNGP_EXTERNALREF_EMTPY, 0);
  add_integer_constant("RNGP_EXTERNAL_REF_FAILURE", XML_RNGP_EXTERNAL_REF_FAILURE, 0);
  add_integer_constant("RNGP_EXTERNALREF_RECURSE", XML_RNGP_EXTERNALREF_RECURSE, 0);
  add_integer_constant("RNGP_FORBIDDEN_ATTRIBUTE", XML_RNGP_FORBIDDEN_ATTRIBUTE, 0);
  add_integer_constant("RNGP_FOREIGN_ELEMENT", XML_RNGP_FOREIGN_ELEMENT, 0);
  add_integer_constant("RNGP_GRAMMAR_CONTENT", XML_RNGP_GRAMMAR_CONTENT, 0);
  add_integer_constant("RNGP_GRAMMAR_EMPTY", XML_RNGP_GRAMMAR_EMPTY, 0);
  add_integer_constant("RNGP_GRAMMAR_MISSING", XML_RNGP_GRAMMAR_MISSING, 0);
  add_integer_constant("RNGP_GRAMMAR_NO_START", XML_RNGP_GRAMMAR_NO_START, 0);
  add_integer_constant("RNGP_GROUP_ATTR_CONFLICT", XML_RNGP_GROUP_ATTR_CONFLICT, 0);
  add_integer_constant("RNGP_HREF_ERROR", XML_RNGP_HREF_ERROR, 0);
  add_integer_constant("RNGP_INCLUDE_EMPTY", XML_RNGP_INCLUDE_EMPTY, 0);
  add_integer_constant("RNGP_INCLUDE_FAILURE", XML_RNGP_INCLUDE_FAILURE, 0);
  add_integer_constant("RNGP_INCLUDE_RECURSE", XML_RNGP_INCLUDE_RECURSE, 0);
  add_integer_constant("RNGP_INTERLEAVE_ADD", XML_RNGP_INTERLEAVE_ADD, 0);
  add_integer_constant("RNGP_INTERLEAVE_CREATE_FAILED", XML_RNGP_INTERLEAVE_CREATE_FAILED, 0);
  add_integer_constant("RNGP_INTERLEAVE_EMPTY", XML_RNGP_INTERLEAVE_EMPTY, 0);
  add_integer_constant("RNGP_INTERLEAVE_NO_CONTENT", XML_RNGP_INTERLEAVE_NO_CONTENT, 0);
  add_integer_constant("RNGP_INVALID_DEFINE_NAME", XML_RNGP_INVALID_DEFINE_NAME, 0);
  add_integer_constant("RNGP_INVALID_URI", XML_RNGP_INVALID_URI, 0);
  add_integer_constant("RNGP_INVALID_VALUE", XML_RNGP_INVALID_VALUE, 0);
  add_integer_constant("RNGP_MISSING_HREF", XML_RNGP_MISSING_HREF, 0);
  add_integer_constant("RNGP_NAME_MISSING", XML_RNGP_NAME_MISSING, 0);
  add_integer_constant("RNGP_NEED_COMBINE", XML_RNGP_NEED_COMBINE, 0);
  add_integer_constant("RNGP_NOTALLOWED_NOT_EMPTY", XML_RNGP_NOTALLOWED_NOT_EMPTY, 0);
  add_integer_constant("RNGP_NSNAME_ATTR_ANCESTOR", XML_RNGP_NSNAME_ATTR_ANCESTOR, 0);
  add_integer_constant("RNGP_NSNAME_NO_NS", XML_RNGP_NSNAME_NO_NS, 0);
  add_integer_constant("RNGP_PARAM_FORBIDDEN", XML_RNGP_PARAM_FORBIDDEN, 0);
  add_integer_constant("RNGP_PARAM_NAME_MISSING", XML_RNGP_PARAM_NAME_MISSING, 0);
  add_integer_constant("RNGP_PARENTREF_CREATE_FAILED", XML_RNGP_PARENTREF_CREATE_FAILED, 0);
  add_integer_constant("RNGP_PARENTREF_NAME_INVALID", XML_RNGP_PARENTREF_NAME_INVALID, 0);
  add_integer_constant("RNGP_PARENTREF_NO_NAME", XML_RNGP_PARENTREF_NO_NAME, 0);
  add_integer_constant("RNGP_PARENTREF_NO_PARENT", XML_RNGP_PARENTREF_NO_PARENT, 0);
  add_integer_constant("RNGP_PARENTREF_NOT_EMPTY", XML_RNGP_PARENTREF_NOT_EMPTY, 0);
  add_integer_constant("RNGP_PARSE_ERROR", XML_RNGP_PARSE_ERROR, 0);
  add_integer_constant("RNGP_PAT_ANYNAME_EXCEPT_ANYNAME", XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME, 0);
  add_integer_constant("RNGP_PAT_ATTR_ATTR", XML_RNGP_PAT_ATTR_ATTR, 0);
  add_integer_constant("RNGP_PAT_ATTR_ELEM", XML_RNGP_PAT_ATTR_ELEM, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_ATTR", XML_RNGP_PAT_DATA_EXCEPT_ATTR, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_ELEM", XML_RNGP_PAT_DATA_EXCEPT_ELEM, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_EMPTY", XML_RNGP_PAT_DATA_EXCEPT_EMPTY, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_GROUP", XML_RNGP_PAT_DATA_EXCEPT_GROUP, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_INTERLEAVE", XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_LIST", XML_RNGP_PAT_DATA_EXCEPT_LIST, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_ONEMORE", XML_RNGP_PAT_DATA_EXCEPT_ONEMORE, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_REF", XML_RNGP_PAT_DATA_EXCEPT_REF, 0);
  add_integer_constant("RNGP_PAT_DATA_EXCEPT_TEXT", XML_RNGP_PAT_DATA_EXCEPT_TEXT, 0);
  add_integer_constant("RNGP_PAT_LIST_ATTR", XML_RNGP_PAT_LIST_ATTR, 0);
  add_integer_constant("RNGP_PAT_LIST_ELEM", XML_RNGP_PAT_LIST_ELEM, 0);
  add_integer_constant("RNGP_PAT_LIST_INTERLEAVE", XML_RNGP_PAT_LIST_INTERLEAVE, 0);
  add_integer_constant("RNGP_PAT_LIST_LIST", XML_RNGP_PAT_LIST_LIST, 0);
  add_integer_constant("RNGP_PAT_LIST_REF", XML_RNGP_PAT_LIST_REF, 0);
  add_integer_constant("RNGP_PAT_LIST_TEXT", XML_RNGP_PAT_LIST_TEXT, 0);
  add_integer_constant("RNGP_PAT_NSNAME_EXCEPT_ANYNAME", XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME, 0);
  add_integer_constant("RNGP_PAT_NSNAME_EXCEPT_NSNAME", XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME, 0);
  add_integer_constant("RNGP_PAT_ONEMORE_GROUP_ATTR", XML_RNGP_PAT_ONEMORE_GROUP_ATTR, 0);
  add_integer_constant("RNGP_PAT_ONEMORE_INTERLEAVE_ATTR", XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR, 0);
  add_integer_constant("RNGP_PAT_START_ATTR", XML_RNGP_PAT_START_ATTR, 0);
  add_integer_constant("RNGP_PAT_START_DATA", XML_RNGP_PAT_START_DATA, 0);
  add_integer_constant("RNGP_PAT_START_EMPTY", XML_RNGP_PAT_START_EMPTY, 0);
  add_integer_constant("RNGP_PAT_START_GROUP", XML_RNGP_PAT_START_GROUP, 0);
  add_integer_constant("RNGP_PAT_START_INTERLEAVE", XML_RNGP_PAT_START_INTERLEAVE, 0);
  add_integer_constant("RNGP_PAT_START_LIST", XML_RNGP_PAT_START_LIST, 0);
  add_integer_constant("RNGP_PAT_START_ONEMORE", XML_RNGP_PAT_START_ONEMORE, 0);
  add_integer_constant("RNGP_PAT_START_TEXT", XML_RNGP_PAT_START_TEXT, 0);
  add_integer_constant("RNGP_PAT_START_VALUE", XML_RNGP_PAT_START_VALUE, 0);
  add_integer_constant("RNGP_PREFIX_UNDEFINED", XML_RNGP_PREFIX_UNDEFINED, 0);
  add_integer_constant("RNGP_REF_CREATE_FAILED", XML_RNGP_REF_CREATE_FAILED, 0);
  add_integer_constant("RNGP_REF_CYCLE", XML_RNGP_REF_CYCLE, 0);
  add_integer_constant("RNGP_REF_NAME_INVALID", XML_RNGP_REF_NAME_INVALID, 0);
  add_integer_constant("RNGP_REF_NO_DEF", XML_RNGP_REF_NO_DEF, 0);
  add_integer_constant("RNGP_REF_NO_NAME", XML_RNGP_REF_NO_NAME, 0);
  add_integer_constant("RNGP_REF_NOT_EMPTY", XML_RNGP_REF_NOT_EMPTY, 0);
  add_integer_constant("RNGP_START_CHOICE_AND_INTERLEAVE", XML_RNGP_START_CHOICE_AND_INTERLEAVE, 0);
  add_integer_constant("RNGP_START_CONTENT", XML_RNGP_START_CONTENT, 0);
  add_integer_constant("RNGP_START_EMPTY", XML_RNGP_START_EMPTY, 0);
  add_integer_constant("RNGP_START_MISSING", XML_RNGP_START_MISSING, 0);
  add_integer_constant("RNGP_TEXT_EXPECTED", XML_RNGP_TEXT_EXPECTED, 0);
  add_integer_constant("RNGP_TEXT_HAS_CHILD", XML_RNGP_TEXT_HAS_CHILD, 0);
  add_integer_constant("RNGP_TYPE_MISSING", XML_RNGP_TYPE_MISSING, 0);
  add_integer_constant("RNGP_TYPE_NOT_FOUND", XML_RNGP_TYPE_NOT_FOUND, 0);
  add_integer_constant("RNGP_TYPE_VALUE", XML_RNGP_TYPE_VALUE, 0);
  add_integer_constant("RNGP_UNKNOWN_ATTRIBUTE", XML_RNGP_UNKNOWN_ATTRIBUTE, 0);
  add_integer_constant("RNGP_UNKNOWN_COMBINE", XML_RNGP_UNKNOWN_COMBINE, 0);
  add_integer_constant("RNGP_UNKNOWN_CONSTRUCT", XML_RNGP_UNKNOWN_CONSTRUCT, 0);
  add_integer_constant("RNGP_UNKNOWN_TYPE_LIB", XML_RNGP_UNKNOWN_TYPE_LIB, 0);
  add_integer_constant("RNGP_URI_FRAGMENT", XML_RNGP_URI_FRAGMENT, 0);
  add_integer_constant("RNGP_URI_NOT_ABSOLUTE", XML_RNGP_URI_NOT_ABSOLUTE, 0);
  add_integer_constant("RNGP_VALUE_EMPTY", XML_RNGP_VALUE_EMPTY, 0);
  add_integer_constant("RNGP_VALUE_NO_CONTENT", XML_RNGP_VALUE_NO_CONTENT, 0);
  add_integer_constant("RNGP_XMLNS_NAME", XML_RNGP_XMLNS_NAME, 0);
  add_integer_constant("RNGP_XML_NS", XML_RNGP_XML_NS, 0);
  add_integer_constant("XPATH_EXPRESSION_OK", XML_XPATH_EXPRESSION_OK, 0);
  add_integer_constant("XPATH_NUMBER_ERROR", XML_XPATH_NUMBER_ERROR, 0);
  add_integer_constant("XPATH_UNFINISHED_LITERAL_ERROR", XML_XPATH_UNFINISHED_LITERAL_ERROR, 0);
  add_integer_constant("XPATH_START_LITERAL_ERROR", XML_XPATH_START_LITERAL_ERROR, 0);
  add_integer_constant("XPATH_VARIABLE_REF_ERROR", XML_XPATH_VARIABLE_REF_ERROR, 0);
  add_integer_constant("XPATH_UNDEF_VARIABLE_ERROR", XML_XPATH_UNDEF_VARIABLE_ERROR, 0);
  add_integer_constant("XPATH_INVALID_PREDICATE_ERROR", XML_XPATH_INVALID_PREDICATE_ERROR, 0);
  add_integer_constant("XPATH_EXPR_ERROR", XML_XPATH_EXPR_ERROR, 0);
  add_integer_constant("XPATH_UNCLOSED_ERROR", XML_XPATH_UNCLOSED_ERROR, 0);
  add_integer_constant("XPATH_UNKNOWN_FUNC_ERROR", XML_XPATH_UNKNOWN_FUNC_ERROR, 0);
  add_integer_constant("XPATH_INVALID_OPERAND", XML_XPATH_INVALID_OPERAND, 0);
  add_integer_constant("XPATH_INVALID_TYPE", XML_XPATH_INVALID_TYPE, 0);
  add_integer_constant("XPATH_INVALID_ARITY", XML_XPATH_INVALID_ARITY, 0);
  add_integer_constant("XPATH_INVALID_CTXT_SIZE", XML_XPATH_INVALID_CTXT_SIZE, 0);
  add_integer_constant("XPATH_INVALID_CTXT_POSITION", XML_XPATH_INVALID_CTXT_POSITION, 0);
  add_integer_constant("XPATH_MEMORY_ERROR", XML_XPATH_MEMORY_ERROR, 0);
  add_integer_constant("XPTR_SYNTAX_ERROR", XML_XPTR_SYNTAX_ERROR, 0);
  add_integer_constant("XPTR_RESOURCE_ERROR", XML_XPTR_RESOURCE_ERROR, 0);
  add_integer_constant("XPTR_SUB_RESOURCE_ERROR", XML_XPTR_SUB_RESOURCE_ERROR, 0);
  add_integer_constant("XPATH_UNDEF_PREFIX_ERROR", XML_XPATH_UNDEF_PREFIX_ERROR, 0);
  add_integer_constant("XPATH_ENCODING_ERROR", XML_XPATH_ENCODING_ERROR, 0);
  add_integer_constant("XPATH_INVALID_CHAR_ERROR", XML_XPATH_INVALID_CHAR_ERROR, 0);
  add_integer_constant("TREE_INVALID_HEX", XML_TREE_INVALID_HEX, 0);
  add_integer_constant("TREE_INVALID_DEC", XML_TREE_INVALID_DEC, 0);
  add_integer_constant("TREE_UNTERMINATED_ENTITY", XML_TREE_UNTERMINATED_ENTITY, 0);
  add_integer_constant("SAVE_NOT_UTF8", XML_SAVE_NOT_UTF8, 0);
  add_integer_constant("SAVE_CHAR_INVALID", XML_SAVE_CHAR_INVALID, 0);
  add_integer_constant("SAVE_NO_DOCTYPE", XML_SAVE_NO_DOCTYPE, 0);
  add_integer_constant("SAVE_UNKNOWN_ENCODING", XML_SAVE_UNKNOWN_ENCODING, 0);
  add_integer_constant("REGEXP_COMPILE_ERROR", XML_REGEXP_COMPILE_ERROR, 0);
  add_integer_constant("IO_UNKNOWN", XML_IO_UNKNOWN, 0);
  add_integer_constant("IO_EACCES", XML_IO_EACCES, 0);
  add_integer_constant("IO_EAGAIN", XML_IO_EAGAIN, 0);
  add_integer_constant("IO_EBADF", XML_IO_EBADF, 0);
  add_integer_constant("IO_EBADMSG", XML_IO_EBADMSG, 0);
  add_integer_constant("IO_EBUSY", XML_IO_EBUSY, 0);
  add_integer_constant("IO_ECANCELED", XML_IO_ECANCELED, 0);
  add_integer_constant("IO_ECHILD", XML_IO_ECHILD, 0);
  add_integer_constant("IO_EDEADLK", XML_IO_EDEADLK, 0);
  add_integer_constant("IO_EDOM", XML_IO_EDOM, 0);
  add_integer_constant("IO_EEXIST", XML_IO_EEXIST, 0);
  add_integer_constant("IO_EFAULT", XML_IO_EFAULT, 0);
  add_integer_constant("IO_EFBIG", XML_IO_EFBIG, 0);
  add_integer_constant("IO_EINPROGRESS", XML_IO_EINPROGRESS, 0);
  add_integer_constant("IO_EINTR", XML_IO_EINTR, 0);
  add_integer_constant("IO_EINVAL", XML_IO_EINVAL, 0);
  add_integer_constant("IO_EIO", XML_IO_EIO, 0);
  add_integer_constant("IO_EISDIR", XML_IO_EISDIR, 0);
  add_integer_constant("IO_EMFILE", XML_IO_EMFILE, 0);
  add_integer_constant("IO_EMLINK", XML_IO_EMLINK, 0);
  add_integer_constant("IO_EMSGSIZE", XML_IO_EMSGSIZE, 0);
  add_integer_constant("IO_ENAMETOOLONG", XML_IO_ENAMETOOLONG, 0);
  add_integer_constant("IO_ENFILE", XML_IO_ENFILE, 0);
  add_integer_constant("IO_ENODEV", XML_IO_ENODEV, 0);
  add_integer_constant("IO_ENOENT", XML_IO_ENOENT, 0);
  add_integer_constant("IO_ENOEXEC", XML_IO_ENOEXEC, 0);
  add_integer_constant("IO_ENOLCK", XML_IO_ENOLCK, 0);
  add_integer_constant("IO_ENOMEM", XML_IO_ENOMEM, 0);
  add_integer_constant("IO_ENOSPC", XML_IO_ENOSPC, 0);
  add_integer_constant("IO_ENOSYS", XML_IO_ENOSYS, 0);
  add_integer_constant("IO_ENOTDIR", XML_IO_ENOTDIR, 0);
  add_integer_constant("IO_ENOTEMPTY", XML_IO_ENOTEMPTY, 0);
  add_integer_constant("IO_ENOTSUP", XML_IO_ENOTSUP, 0);
  add_integer_constant("IO_ENOTTY", XML_IO_ENOTTY, 0);
  add_integer_constant("IO_ENXIO", XML_IO_ENXIO, 0);
  add_integer_constant("IO_EPERM", XML_IO_EPERM, 0);
  add_integer_constant("IO_EPIPE", XML_IO_EPIPE, 0);
  add_integer_constant("IO_ERANGE", XML_IO_ERANGE, 0);
  add_integer_constant("IO_EROFS", XML_IO_EROFS, 0);
  add_integer_constant("IO_ESPIPE", XML_IO_ESPIPE, 0);
  add_integer_constant("IO_ESRCH", XML_IO_ESRCH, 0);
  add_integer_constant("IO_ETIMEDOUT", XML_IO_ETIMEDOUT, 0);
  add_integer_constant("IO_EXDEV", XML_IO_EXDEV, 0);
  add_integer_constant("IO_NETWORK_ATTEMPT", XML_IO_NETWORK_ATTEMPT, 0);
  add_integer_constant("IO_ENCODER", XML_IO_ENCODER, 0);
  add_integer_constant("IO_FLUSH", XML_IO_FLUSH, 0);
  add_integer_constant("IO_WRITE", XML_IO_WRITE, 0);
  add_integer_constant("IO_NO_INPUT", XML_IO_NO_INPUT, 0);
  add_integer_constant("IO_BUFFER_FULL", XML_IO_BUFFER_FULL, 0);
  add_integer_constant("IO_LOAD_ERROR", XML_IO_LOAD_ERROR, 0);
  add_integer_constant("IO_ENOTSOCK", XML_IO_ENOTSOCK, 0);
  add_integer_constant("IO_EISCONN", XML_IO_EISCONN, 0);
  add_integer_constant("IO_ECONNREFUSED", XML_IO_ECONNREFUSED, 0);
  add_integer_constant("IO_ENETUNREACH", XML_IO_ENETUNREACH, 0);
  add_integer_constant("IO_EADDRINUSE", XML_IO_EADDRINUSE, 0);
  add_integer_constant("IO_EALREADY", XML_IO_EALREADY, 0);
  add_integer_constant("IO_EAFNOSUPPORT", XML_IO_EAFNOSUPPORT, 0);
  add_integer_constant("XINCLUDE_RECURSION", XML_XINCLUDE_RECURSION, 0);
  add_integer_constant("XINCLUDE_PARSE_VALUE", XML_XINCLUDE_PARSE_VALUE, 0);
  add_integer_constant("XINCLUDE_ENTITY_DEF_MISMATCH", XML_XINCLUDE_ENTITY_DEF_MISMATCH, 0);
  add_integer_constant("XINCLUDE_NO_HREF", XML_XINCLUDE_NO_HREF, 0);
  add_integer_constant("XINCLUDE_NO_FALLBACK", XML_XINCLUDE_NO_FALLBACK, 0);
  add_integer_constant("XINCLUDE_HREF_URI", XML_XINCLUDE_HREF_URI, 0);
  add_integer_constant("XINCLUDE_TEXT_FRAGMENT", XML_XINCLUDE_TEXT_FRAGMENT, 0);
  add_integer_constant("XINCLUDE_TEXT_DOCUMENT", XML_XINCLUDE_TEXT_DOCUMENT, 0);
  add_integer_constant("XINCLUDE_INVALID_CHAR", XML_XINCLUDE_INVALID_CHAR, 0);
  add_integer_constant("XINCLUDE_BUILD_FAILED", XML_XINCLUDE_BUILD_FAILED, 0);
  add_integer_constant("XINCLUDE_UNKNOWN_ENCODING", XML_XINCLUDE_UNKNOWN_ENCODING, 0);
  add_integer_constant("XINCLUDE_MULTIPLE_ROOT", XML_XINCLUDE_MULTIPLE_ROOT, 0);
  add_integer_constant("XINCLUDE_XPTR_FAILED", XML_XINCLUDE_XPTR_FAILED, 0);
  add_integer_constant("XINCLUDE_XPTR_RESULT", XML_XINCLUDE_XPTR_RESULT, 0);
  add_integer_constant("XINCLUDE_INCLUDE_IN_INCLUDE", XML_XINCLUDE_INCLUDE_IN_INCLUDE, 0);
  add_integer_constant("XINCLUDE_FALLBACKS_IN_INCLUDE", XML_XINCLUDE_FALLBACKS_IN_INCLUDE, 0);
  add_integer_constant("XINCLUDE_FALLBACK_NOT_IN_INCLUDE", XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE, 0);
  add_integer_constant("XINCLUDE_DEPRECATED_NS", XML_XINCLUDE_DEPRECATED_NS, 0);
  add_integer_constant("XINCLUDE_FRAGMENT_ID", XML_XINCLUDE_FRAGMENT_ID, 0);
  add_integer_constant("CATALOG_MISSING_ATTR", XML_CATALOG_MISSING_ATTR, 0);
  add_integer_constant("CATALOG_ENTRY_BROKEN", XML_CATALOG_ENTRY_BROKEN, 0);
  add_integer_constant("CATALOG_PREFER_VALUE", XML_CATALOG_PREFER_VALUE, 0);
  add_integer_constant("CATALOG_NOT_CATALOG", XML_CATALOG_NOT_CATALOG, 0);
  add_integer_constant("CATALOG_RECURSION", XML_CATALOG_RECURSION, 0);
  add_integer_constant("SCHEMAP_PREFIX_UNDEFINED", XML_SCHEMAP_PREFIX_UNDEFINED, 0);
  add_integer_constant("SCHEMAP_ATTRFORMDEFAULT_VALUE", XML_SCHEMAP_ATTRFORMDEFAULT_VALUE, 0);
  add_integer_constant("SCHEMAP_ATTRGRP_NONAME_NOREF", XML_SCHEMAP_ATTRGRP_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_ATTR_NONAME_NOREF", XML_SCHEMAP_ATTR_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_COMPLEXTYPE_NONAME_NOREF", XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_ELEMFORMDEFAULT_VALUE", XML_SCHEMAP_ELEMFORMDEFAULT_VALUE, 0);
  add_integer_constant("SCHEMAP_ELEM_NONAME_NOREF", XML_SCHEMAP_ELEM_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_EXTENSION_NO_BASE", XML_SCHEMAP_EXTENSION_NO_BASE, 0);
  add_integer_constant("SCHEMAP_FACET_NO_VALUE", XML_SCHEMAP_FACET_NO_VALUE, 0);
  add_integer_constant("SCHEMAP_FAILED_BUILD_IMPORT", XML_SCHEMAP_FAILED_BUILD_IMPORT, 0);
  add_integer_constant("SCHEMAP_GROUP_NONAME_NOREF", XML_SCHEMAP_GROUP_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_IMPORT_NAMESPACE_NOT_URI", XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI, 0);
  add_integer_constant("SCHEMAP_IMPORT_REDEFINE_NSNAME", XML_SCHEMAP_IMPORT_REDEFINE_NSNAME, 0);
  add_integer_constant("SCHEMAP_IMPORT_SCHEMA_NOT_URI", XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI, 0);
  add_integer_constant("SCHEMAP_INVALID_BOOLEAN", XML_SCHEMAP_INVALID_BOOLEAN, 0);
  add_integer_constant("SCHEMAP_INVALID_ENUM", XML_SCHEMAP_INVALID_ENUM, 0);
  add_integer_constant("SCHEMAP_INVALID_FACET", XML_SCHEMAP_INVALID_FACET, 0);
  add_integer_constant("SCHEMAP_INVALID_FACET_VALUE", XML_SCHEMAP_INVALID_FACET_VALUE, 0);
  add_integer_constant("SCHEMAP_INVALID_MAXOCCURS", XML_SCHEMAP_INVALID_MAXOCCURS, 0);
  add_integer_constant("SCHEMAP_INVALID_MINOCCURS", XML_SCHEMAP_INVALID_MINOCCURS, 0);
  add_integer_constant("SCHEMAP_INVALID_REF_AND_SUBTYPE", XML_SCHEMAP_INVALID_REF_AND_SUBTYPE, 0);
  add_integer_constant("SCHEMAP_INVALID_WHITE_SPACE", XML_SCHEMAP_INVALID_WHITE_SPACE, 0);
  add_integer_constant("SCHEMAP_NOATTR_NOREF", XML_SCHEMAP_NOATTR_NOREF, 0);
  add_integer_constant("SCHEMAP_NOTATION_NO_NAME", XML_SCHEMAP_NOTATION_NO_NAME, 0);
  add_integer_constant("SCHEMAP_NOTYPE_NOREF", XML_SCHEMAP_NOTYPE_NOREF, 0);
  add_integer_constant("SCHEMAP_REF_AND_SUBTYPE", XML_SCHEMAP_REF_AND_SUBTYPE, 0);
  add_integer_constant("SCHEMAP_RESTRICTION_NONAME_NOREF", XML_SCHEMAP_RESTRICTION_NONAME_NOREF, 0);
  add_integer_constant("SCHEMAP_SIMPLETYPE_NONAME", XML_SCHEMAP_SIMPLETYPE_NONAME, 0);
  add_integer_constant("SCHEMAP_TYPE_AND_SUBTYPE", XML_SCHEMAP_TYPE_AND_SUBTYPE, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_ALL_CHILD", XML_SCHEMAP_UNKNOWN_ALL_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD", XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD, 
0);
  add_integer_constant("SCHEMAP_UNKNOWN_ATTR_CHILD", XML_SCHEMAP_UNKNOWN_ATTR_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_ATTRGRP_CHILD", XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP", XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_BASE_TYPE", XML_SCHEMAP_UNKNOWN_BASE_TYPE, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_CHOICE_CHILD", XML_SCHEMAP_UNKNOWN_CHOICE_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD", XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD", XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_ELEM_CHILD", XML_SCHEMAP_UNKNOWN_ELEM_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_EXTENSION_CHILD", XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_FACET_CHILD", XML_SCHEMAP_UNKNOWN_FACET_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_FACET_TYPE", XML_SCHEMAP_UNKNOWN_FACET_TYPE, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_GROUP_CHILD", XML_SCHEMAP_UNKNOWN_GROUP_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_IMPORT_CHILD", XML_SCHEMAP_UNKNOWN_IMPORT_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_LIST_CHILD", XML_SCHEMAP_UNKNOWN_LIST_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_NOTATION_CHILD", XML_SCHEMAP_UNKNOWN_NOTATION_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD", XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_REF", XML_SCHEMAP_UNKNOWN_REF, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_RESTRICTION_CHILD", XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_SCHEMAS_CHILD", XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_SEQUENCE_CHILD", XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD", XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD", XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_TYPE", XML_SCHEMAP_UNKNOWN_TYPE, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_UNION_CHILD", XML_SCHEMAP_UNKNOWN_UNION_CHILD, 0);
  add_integer_constant("SCHEMAP_ELEM_DEFAULT_FIXED", XML_SCHEMAP_ELEM_DEFAULT_FIXED, 0);
  add_integer_constant("SCHEMAP_REGEXP_INVALID", XML_SCHEMAP_REGEXP_INVALID, 0);
  add_integer_constant("SCHEMAP_FAILED_LOAD", XML_SCHEMAP_FAILED_LOAD, 0);
  add_integer_constant("SCHEMAP_NOTHING_TO_PARSE", XML_SCHEMAP_NOTHING_TO_PARSE, 0);
  add_integer_constant("SCHEMAP_NOROOT", XML_SCHEMAP_NOROOT, 0);
  add_integer_constant("SCHEMAP_REDEFINED_GROUP", XML_SCHEMAP_REDEFINED_GROUP, 0);
  add_integer_constant("SCHEMAP_REDEFINED_TYPE", XML_SCHEMAP_REDEFINED_TYPE, 0);
  add_integer_constant("SCHEMAP_REDEFINED_ELEMENT", XML_SCHEMAP_REDEFINED_ELEMENT, 0);
  add_integer_constant("SCHEMAP_REDEFINED_ATTRGROUP", XML_SCHEMAP_REDEFINED_ATTRGROUP, 0);
  add_integer_constant("SCHEMAP_REDEFINED_ATTR", XML_SCHEMAP_REDEFINED_ATTR, 0);
  add_integer_constant("SCHEMAP_REDEFINED_NOTATION", XML_SCHEMAP_REDEFINED_NOTATION, 0);
  add_integer_constant("SCHEMAP_FAILED_PARSE", XML_SCHEMAP_FAILED_PARSE, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_PREFIX", XML_SCHEMAP_UNKNOWN_PREFIX, 0);
  add_integer_constant("SCHEMAP_DEF_AND_PREFIX", XML_SCHEMAP_DEF_AND_PREFIX, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_INCLUDE_CHILD", XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD, 0);
  add_integer_constant("SCHEMAP_INCLUDE_SCHEMA_NOT_URI", XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI, 0);
  add_integer_constant("SCHEMAP_INCLUDE_SCHEMA_NO_URI", XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI, 0);
  add_integer_constant("SCHEMAP_NOT_SCHEMA", XML_SCHEMAP_NOT_SCHEMA, 0);
  add_integer_constant("SCHEMAP_UNKNOWN_MEMBER_TYPE", XML_SCHEMAP_UNKNOWN_MEMBER_TYPE, 0);
  add_integer_constant("SCHEMAP_INVALID_ATTR_USE", XML_SCHEMAP_INVALID_ATTR_USE, 0);
  add_integer_constant("SCHEMAP_RECURSIVE", XML_SCHEMAP_RECURSIVE, 0);
  add_integer_constant("SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE", XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE, 0);
  add_integer_constant("SCHEMAP_INVALID_ATTR_COMBINATION", XML_SCHEMAP_INVALID_ATTR_COMBINATION, 0);
  add_integer_constant("SCHEMAP_INVALID_ATTR_INLINE_COMBINATION", XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION, 0);
  add_integer_constant("SCHEMAP_MISSING_SIMPLETYPE_CHILD", XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD, 0);
  add_integer_constant("SCHEMAP_INVALID_ATTR_NAME", XML_SCHEMAP_INVALID_ATTR_NAME, 0);
  add_integer_constant("SCHEMAP_REF_AND_CONTENT", XML_SCHEMAP_REF_AND_CONTENT, 0);
  add_integer_constant("SCHEMAV_NOROOT", XML_SCHEMAV_NOROOT, 0);
  add_integer_constant("SCHEMAV_UNDECLAREDELEM", XML_SCHEMAV_UNDECLAREDELEM, 0);
  add_integer_constant("SCHEMAV_NOTTOPLEVEL", XML_SCHEMAV_NOTTOPLEVEL, 0);
  add_integer_constant("SCHEMAV_MISSING", XML_SCHEMAV_MISSING, 0);
  add_integer_constant("SCHEMAV_WRONGELEM", XML_SCHEMAV_WRONGELEM, 0);
  add_integer_constant("SCHEMAV_NOTYPE", XML_SCHEMAV_NOTYPE, 0);
  add_integer_constant("SCHEMAV_NOROLLBACK", XML_SCHEMAV_NOROLLBACK, 0);
  add_integer_constant("SCHEMAV_ISABSTRACT", XML_SCHEMAV_ISABSTRACT, 0);
  add_integer_constant("SCHEMAV_NOTEMPTY", XML_SCHEMAV_NOTEMPTY, 0);
  add_integer_constant("SCHEMAV_ELEMCONT", XML_SCHEMAV_ELEMCONT, 0);
  add_integer_constant("SCHEMAV_HAVEDEFAULT", XML_SCHEMAV_HAVEDEFAULT, 0);
  add_integer_constant("SCHEMAV_NOTNILLABLE", XML_SCHEMAV_NOTNILLABLE, 0);
  add_integer_constant("SCHEMAV_EXTRACONTENT", XML_SCHEMAV_EXTRACONTENT, 0);
  add_integer_constant("SCHEMAV_INVALIDATTR", XML_SCHEMAV_INVALIDATTR, 0);
  add_integer_constant("SCHEMAV_INVALIDELEM", XML_SCHEMAV_INVALIDELEM, 0);
  add_integer_constant("SCHEMAV_NOTDETERMINIST", XML_SCHEMAV_NOTDETERMINIST, 0);
  add_integer_constant("SCHEMAV_CONSTRUCT", XML_SCHEMAV_CONSTRUCT, 0);
  add_integer_constant("SCHEMAV_INTERNAL", XML_SCHEMAV_INTERNAL, 0);
  add_integer_constant("SCHEMAV_NOTSIMPLE", XML_SCHEMAV_NOTSIMPLE, 0);  
  add_integer_constant("SCHEMAV_ATTRUNKNOWN", XML_SCHEMAV_ATTRUNKNOWN, 0);
  add_integer_constant("SCHEMAV_ATTRINVALID", XML_SCHEMAV_ATTRINVALID, 0);
  add_integer_constant("SCHEMAV_VALUE", XML_SCHEMAV_VALUE, 0);
  add_integer_constant("SCHEMAV_FACET", XML_SCHEMAV_FACET, 0);
  add_integer_constant("XPTR_UNKNOWN_SCHEME", XML_XPTR_UNKNOWN_SCHEME, 0);
  add_integer_constant("XPTR_CHILDSEQ_START", XML_XPTR_CHILDSEQ_START, 0);
  add_integer_constant("XPTR_EVAL_FAILED", XML_XPTR_EVAL_FAILED, 0);
  add_integer_constant("XPTR_EXTRA_OBJECTS", XML_XPTR_EXTRA_OBJECTS, 0);
  add_integer_constant("C14N_CREATE_CTXT", XML_C14N_CREATE_CTXT, 0);
  add_integer_constant("C14N_REQUIRES_UTF8", XML_C14N_REQUIRES_UTF8, 0);
  add_integer_constant("C14N_CREATE_STACK", XML_C14N_CREATE_STACK, 0);
  add_integer_constant("C14N_INVALID_NODE", XML_C14N_INVALID_NODE, 0);
  add_integer_constant("FTP_PASV_ANSWER", XML_FTP_PASV_ANSWER, 0);
  add_integer_constant("FTP_EPSV_ANSWER", XML_FTP_EPSV_ANSWER, 0);
  add_integer_constant("FTP_ACCNT", XML_FTP_ACCNT, 0);
  add_integer_constant("HTTP_URL_SYNTAX", XML_HTTP_URL_SYNTAX, 0);
  add_integer_constant("HTTP_USE_IP", XML_HTTP_USE_IP, 0);
  add_integer_constant("HTTP_UNKNOWN_HOST", XML_HTTP_UNKNOWN_HOST, 0);

  /* error levels */
  add_integer_constant("ERR_NONE", XML_ERR_NONE, 0);
  add_integer_constant("ERR_WARNING", XML_ERR_WARNING, 0);
  add_integer_constant("ERR_ERROR", XML_ERR_ERROR, 0);
  add_integer_constant("ERR_FATAL", XML_ERR_FATAL, 0);

  /* error domains */
  add_integer_constant("FROM_NONE", XML_FROM_NONE, 0);
  add_integer_constant("FROM_PARSER", XML_FROM_PARSER, 0);
  add_integer_constant("FROM_TREE", XML_FROM_TREE, 0);
  add_integer_constant("FROM_NAMESPACE", XML_FROM_NAMESPACE, 0);
  add_integer_constant("FROM_DTD", XML_FROM_DTD, 0);
  add_integer_constant("FROM_HTML", XML_FROM_HTML, 0);
  add_integer_constant("FROM_MEMORY", XML_FROM_MEMORY, 0);
  add_integer_constant("FROM_OUTPUT", XML_FROM_OUTPUT, 0);
  add_integer_constant("FROM_IO", XML_FROM_IO, 0);
  add_integer_constant("FROM_FTP", XML_FROM_FTP, 0);
  add_integer_constant("FROM_HTTP", XML_FROM_HTTP, 0);
  add_integer_constant("FROM_XINCLUDE", XML_FROM_XINCLUDE, 0);
  add_integer_constant("FROM_XPATH", XML_FROM_XPATH, 0);
  add_integer_constant("FROM_XPOINTER", XML_FROM_XPOINTER, 0);
  add_integer_constant("FROM_REGEXP", XML_FROM_REGEXP, 0);
  add_integer_constant("FROM_DATATYPE", XML_FROM_DATATYPE, 0);
  add_integer_constant("FROM_SCHEMASP", XML_FROM_SCHEMASP, 0);
  add_integer_constant("FROM_SCHEMASV", XML_FROM_SCHEMASV, 0);
  add_integer_constant("FROM_RELAXNGP", XML_FROM_RELAXNGP, 0);
  add_integer_constant("FROM_RELAXNGV", XML_FROM_RELAXNGV, 0);
  add_integer_constant("FROM_CATALOG", XML_FROM_CATALOG, 0);
  add_integer_constant("FROM_C14N", XML_FROM_C14N, 0);
  add_integer_constant("FROM_XSLT", XML_FROM_XSLT, 0);
  add_integer_constant("FROM_VALID", XML_FROM_VALID, 0);

}
}
/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

/*! @endmodule
 */



